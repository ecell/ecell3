  <!-- ================ Writing em ================================ -->

  <chapter id="modeling"> 
  <title>Modeling with &ecell;</title> 

  <highlights>
    <para>By reading this chapter, you can get information about:</para>
    
    <simplelist>
      <member>How an &ecell;'s simulation model is organized.</member>
      <member>How to create a simulation model.</member>
      <member>How to write a model file in &EM; format.</member>
    </simplelist>
  </highlights>


  <sect1>
    <title>Objects In The Model</title>

    <para>
    &ecell;'s simulation model is fully object-oriented.  That is, the
    simulation model is actually a set of <emphasis>objects</emphasis>
    connected each other.  The objects have
    <emphasis>properties</emphasis>, which determine characteristics
    of the objects (such as a reaction rate constant if the object
    represent a chemical reaction) and relationships between
    the objects.
    </para>

    <sect2>
      <title>Types Of The Objects</title>

      <para>A simulation model of &app; consists of the following types of objects.
<itemizedlist>
	  <listitem>
	    <para>Usually more than one &Entity; objects</para>
	  </listitem>
	  <listitem>
	    <para>One or more &Stepper; object(s)</para>
	  </listitem>
	</itemizedlist>
&Entity; objects define the structure of the simulation model and represented phenomena (such
as chemical reactions) in the model. &Stepper; objects
implement specific simulation algorithms.
</para>

    <sect3>
      <title>Entity objects</title>

      <para>
The &Entity; class has three subclasses:
<itemizedlist>
	  <listitem>
	    <para>&Variable;</para> <para>This class of objects represent state
	  variables.  A &Variable; object holds a scalar real-number
	  value.  A set of values of all &Variable; objects in a
	  simulation model defines the state of the model at a certain
	  point in time.</para>
	  </listitem>
	  <listitem>
	    <para>&Process;</para> <para>This class of objects
	  represent phenomena in the simulation model that result in
	  changes in the values of one or more &Variable; objects.
	  The way of change of the &Variable; values can be either
	  discrete or continuous.</para>
	  </listitem>
	  <listitem>
	    <para>&System;</para> <para>This class of objects define
	  overall structure of the model.  A &System; object can
	  contain sets of these three types of &Entity;, &Variable;,
	  &Process;, and &System; objects.  A &System; can contain
	  other &System;s, and can form a tree-like structure.  
	  </para>
	  </listitem>
	</itemizedlist>
</para>

    </sect3>

      <sect3>
	<title>Stepper objects</title>
	
	<para>A model must have one or more &Stepper; object(s).  Each
      &Process; and &System; object must be connected with a &Stepper;
      object in the same model.  In other words, &Stepper; objects in
      the model have non-overlapping sets of &Process; and &System;
      objects.</para>
	
	<para>&Stepper; is a class which implement a specific simulation
      algorithm.  If the model has more than one &Stepper; objects,
      the system conducts a multi-stepper
      simulation.  In addition to the lists of &Process; and &System;
      objects, a &Stepper; has a list of &Variable; objects that can
      be read or written by its &Process; objects.  It also has a time
      step interval as a positive real-number.  The system schedules
      &Stepper; objects according to the step intervals, and updates
      the current time.</para>
	
	<para>When called by the system, a &Stepper; object integrates
      values of related &Variable; objects to the current time (if the
      model has a differential component), calls zero, one or more
      &Process; objects connected with the &Stepper; in an order
      determined by its implementation of the algorithm, and
      determines the next time step interval.  See the following
      chapters for details of the simulation procedure.</para>

    </sect3>

    </sect2>


    <sect2>
      <title>Object Identifiers</title>

      <para>&app; uses several types of identifier strings to specify
      the objects, such as the &Entity; and &Stepper; objects, in a
      simulation model.</para>

      <sect3>
	<title>ID (&EntityID; and &StepperID;)</title>

	<para>Every &Entity; and &Stepper; object has an
	<emphasis>ID</emphasis>.  ID is a character string of
	arbitrary length starting from an alphabet or '_' with
	succeeding alphabet, '_', and numeric characters.  &app; treats
	IDs in a case-sensitive way.</para>

	<para>If the ID is used to indicate a &Stepper; object, it is
	called a &StepperID;.  The ID points to an &Entity; object is
	refered to as &EntityID;, or just
	<emphasis>ID</emphasis>.</para>

	<para>(need EBNF here)</para>

	<informalexample>
	  <para>Examples: <literal>_P3</literal>, <literal>ATP</literal>, <literal>GlucoKinase</literal></para>
	</informalexample>

      </sect3>

      <sect3>
	<title>SystemPath;</title>

	<para>The &SystemPath; identifies a &System; from the
	tree-like hierarchy of &System; objects in a simulation model.
	It has a form of &EntityID; strings joined by a character '/'
	(slash).  As a special case, the &SystemPath; of the root
	system is <literal>/</literal>. For instance, if there is a
	&System; <literal>A</literal>, and <literal>A</literal> has a
	subsystem <literal>B</literal>, a &SystemPath;
	<literal>/A/B</literal> specifies the &System; object
	<literal>B</literal>.  It has three parts: (1) the root system
	(<literal>/</literal>), (2) the &System; <literal>A</literal>
	directly under the root system, and (3) the &System;
	<literal>B</literal> just under <literal>A</literal>.</para>

	<para>A &SystemPath; can be relative.  The relative
	&SystemPath; does not point at a &System; object unless the
	current &System; is given.  A &SystemPath; is relative if (1)
	it does not start with the leading <literal>/</literal> (the
	root system), or (2) it contains '<literal>.</literal>' (the
	current system) or '<literal>..</literal>' (the super-system).
	</para>

	<informalexample>
	  <para>Examples: <literal>/A/B</literal>,
	  <literal>../A</literal>, <literal>.</literal>,
	  <literal>/CELL/ER1/../CYTOSOL</literal></para>
	</informalexample>

      </sect3>

      <sect3>
	<title>FullID</title>

	<para>A &FullID; (FULLy qualified IDentifier) identifies a
	unique &Entity; object in a simulation model.  A &FullID;
	comprises three parts, (1) a &EntityType;, (2) a &SystemPath;,
	and (3) an &EntityID;, joined by a character
	'<literal>:</literal>' (colon).

<programlisting><replaceable>EntityType</replaceable>:<replaceable>SystemPath</replaceable>:<replaceable>ID</replaceable></programlisting>

</para>

	<para>The &EntityType; is one of the following class names:
<itemizedlist>
	    <listitem>
	      <para>&System;</para>
	    </listitem>
	    <listitem>
	      <para>&Process;</para>
	    </listitem>
	    <listitem>
	      <para>&Variable;</para>
	    </listitem>
	  </itemizedlist>
</para>

	<para>For example, the following &FullID; points to a
&Process; object of which &EntityID; is '<literal>P</literal>', in the
&System; '<literal>CELL</literal>' immediately under the root system
(<literal>/</literal>).
<informalexample>
	    <programlisting>Process:/CELL:P</programlisting>
	  </informalexample>
</para>

      </sect3>

      <sect3>
	<title>FullPN</title>

	<para>&FullPN; (FULLy qualified Property Name) specifies a
	unique <emphasis>property</emphasis> (see the next section) of
	an &Entity; object in the simulation model.  It has a form of
	a &FullID; and the name of the property joined by a character
	'<literal>:</literal>' (colon).

<programlisting><replaceable>FullID</replaceable>:<replaceable>property_name</replaceable></programlisting>

        or,

<programlisting><replaceable>EntityType</replaceable>:<replaceable>SystemPath</replaceable>:<replaceable>ID</replaceable>:<replaceable>property_name</replaceable></programlisting>
</para>

	<para>The following &FullPN; points to 
	'<property>Value</property>' property of the &Variable; object
	<literal>Variable:/CELL:S</literal>.
<informalexample>
	    <programlisting>Variable:/CELL:S:Value</programlisting>
	  </informalexample>
</para>
      </sect3>

    </sect2>



    <sect2>
      <title>Object Properties</title>

      <para>&Entity; and &Stepper; objects have
      <emphasis>properties</emphasis>.  A property is an attribute of a
      certain object associated with a name.  Its value can be get from and
      set to the object.
      </para>

      <sect3>

	<title>Types of object properties</title>


	<para>A value of a property has a <emphasis>type</emphasis>,
      which is one of the followings.

<itemizedlist>
	    <listitem>
	      <para>&Real; number</para> 
	      <para>(ex. <literal>3.33e+10</literal>, <literal>1.0</literal>)</para>
	    </listitem>
	    <listitem>
	      <para>&Integer; number</para>
	      <para>(ex. <literal>3</literal>, <literal>100</literal>)</para>
	    </listitem>
	    <listitem>
	      <para>&StringType;</para>

	      <para>&StringType; has two forms: quoted and not quoted.
	    A quoted &StringType; can contain any
	    <acronym>ASCII</acronym> characters except the quotation
	    characters (' or ").  Quotations can be omitted if the
	    string has a form of a valid object identifier
	    (&EntityID;, &StepperID;, &SystemPath;, &FullID;, or
	    &FullPN;).</para>

	      <para>If the &StringType; is triple-quoted (by
             <literal>'''</literal> or <literal>"""</literal>), it
             can contain new-line characters.  (The current version still has
             some problems processing this.)</para>

	      <para>(ex. <literal>_C10_A</literal>,
	      <literal>Process:/A/B:P1</literal>, <literal>"It can
	      include spaces if double-quoted."</literal>,
	      <literal>'single-quote is available too, if you want to
	      use "double-quotes" inside.'</literal>)</para>
	    </listitem>

	    <listitem>
	      <para>List</para> 

	      <para>The list can contain &Real;, &Integer;, and
	       &StringType; values. This list can also contain other
	       lists, that is, the list can be nested.  A list must be
	       surrounded by brackets (<literal>[</literal> and
	       <literal>]</literal>), and the elements must be
	       separated by space characters.  In some cases outermost
	       brackets are omitted (such as in &EM; files, see
	       below).</para> 

	      <para>(ex. <literal>[ A 10 [ 1.0 "a string" 1e+10 ]
	      ]</literal> )</para>
	    </listitem>
	  </itemizedlist>
</para>
      </sect3>

      <sect3>
	<title>Dynamic type adaptation of property values</title>

	<para>The system automatically convert the type of the
         property value if it is different from what the object in
         the simulator (such as &Process; and &Variable;) expects to
         get.  That is, the system does not necessary raise an error
         if the type of the given value differs from the type the
         backend object accepts.  The system tries to convert the type
         of the value given in the model file to the requested type by
         the objects in the simulator.  The conversion is done by the
         objects in the simulator, when it gets a property value.  See also the
         following sections.</para>

	<para>The conversion is done in the following manner.  
<itemizedlist>
	    <title>How property value type adaptation is conducted</title>
	    <listitem>
	      <para>From a numeric value (&Real; or &Integer;)</para>
	      <itemizedlist>
		<listitem>
		  <para>To a &StringType;</para> 

		  <para>The number is simply converted to a character
		  string. For example, a number 12.3 is converted to a
		  &StringType; <literal>'12.3'</literal>.</para>
		</listitem>
		<listitem>
		  <para>To a list</para>

		  <para>A numeric value can be converted to a length-1
		  list which has that number as the first item.  For
		  example, 12.3 is equivalent to '[ 12.3 ]'.</para>
		</listitem>
	      </itemizedlist>
	    </listitem>
	    <listitem>
	      <para>From a &StringType;</para>
	      <itemizedlist>
		<listitem>
		  <para>To a numeric value (&Real; or &Integer;)</para> 
		  
		  <para>The initial portion of the &StringType; is
                  converted to a numeric value.  The number can be
                  represented either in a decimal form or a
                  hexadecimal form.  Leading white space characters
                  are ignored.  'INF' and 'NAN' (case-insensitive) are
                  converted to an infinity and a NaN (not-a-number),
                  respectively.  If the initial portion of the
                  &StringType; cannot be converted to a numeric value,
                  it is interpreted as a zero (0.0 or 0).  This
                  conversion procedure is equivalent to C functions
                  <function>strtol</function> and
                  <function>strtod</function>, according to the
                  destined type.</para>
		</listitem>
		<listitem>
		  <para>To a list</para>

		  <para>A &StringType; can be converted to a length-1
		  list which has that &StringType; as the first item.  For
		  example, 'string' is equivalent to '[ 'string' ]'.</para>
		</listitem>
	      </itemizedlist>
	    </listitem>
	    <listitem>
	      <para>From a list</para>
	      <itemizedlist>
		<listitem>
		  <para>To a numeric or a &StringType; value</para> 

		  <para>It simply takes the first item of the list.
		  If necessary the taken value is further converted to
		  the destined types.</para>
		</listitem>
	      </itemizedlist>
	    </listitem>
	  </itemizedlist>


<note>
	    <title>Overflow and underflow when converting a property
	    value</title> 

	    <para>When converting from a &Real; number to an &Integer;, or
	    from a &StringType; to a numeric value, overflow and
	    underflow can occur during the conversion.  In this case
	    an exception (TYPE??) is raised when the backend object
	    attempts the conversion.</para>
	  </note>

</para>


      </sect3>

    </sect2>

  </sect1>


  <sect1>
    <title>E-Cell Model (&EM;) File Basics</title>

    <para>Now you know the &ecell;'s simulation model consists of what
     types of objects, and the objects have their properties.  The
     next thing to understand is how the simulation model is
     organized: the structure of the model.  But wait, learn the
     syntax of the &ecell; model (&EM;) file before proceeding to the
     next section would help you very much to understand the details
     of the structure of the model, because most of the example codes are
     in &EM;.</para>

    <sect2>
      <title>What Is &EM;?</title>

      <para>
      In &app;, the standard file format of model description and
      exchange is XML-based &EML; (E-Cell Model description Language).
      Although &EML; is an ideal means of integrating E-Cell with other
      software components such as GUI model editors and databases, it
      is very tedious for human users to write and edit by hand.</para>

      <para>E-Cell Model (&EM;) is a file
      format with a programming language-like syntax and a powerful
      embedded &empy; preprocessor, which is
      designed to be productive and intuitive especially when handled
      by text editors and other text processing programs.
      Semantics of &EM; and &EML; files
      are almost completely equivalent to each other, and going
      between these two formats is meant to be possible with no loss
      of information (some exceptions are comments and directions to
      the preprocessor in &EM;).  The file suffix of &EM; files is
      ".em".
    </para>

      <sect3>
	<title>Why and when use &EM;?</title>

	<para>Although <application>E-Cell Modeling
         Environment</application> (which is under development) will
         provide means of more sophisticated, scalable and intelligent
         model construction on the basis of &EML;, learning syntax and
         semantics of &EM; may help you get the idea of how object
         model inside &ecell; is organized and how it is driven to
         conduct simulations.  Furthermore, owing to the nature of
         the plain programming language-like syntax, &EM; can be used as a
         simple and intuitive tool to communicate with other &ecell;
         users.  In fact, this manual uses &EM; to illustrate how the
         model is constructed in &ecell;</para>

	<para>&EM; files can be viewed as &EML; generator scripts.</para>

      </sect3>

    </sect2>

    <sect2>
      <title>&EM; At A Glance</title>

      <para>Before getting into the details of &EM; syntax, let's
      have a look at a tiny example. It's very simple, but you do not 
      need to understand everything for the moment.</para>

      <example>
	<title>A tiny &EM; example</title>
	<programlisting linenumbering="numbered">
Stepper ODE45Stepper( ODE_1 ) 
{ 
        # no property 
} 
 
System System( / ) 
{ 
        StepperID       ODE_1;

        Variable Variable( SIZE )
        {
                Value   1e-18; 
        }
 
        Variable Variable( S ) 
        { 
                Value   10000; 
        } 
 
        Variable Variable( P ) 
        { 
                Value   0; 
        } 

        Process MassActionFluxProcess( E ) 
        { 
                Name  "A mass action from S to P."
                k     1.0; 

                VariableReferenceList [ S0 :.:S -1 ] 
                                      [ P0 :.:P 1 ];
        } 
 
} 
</programlisting>
      </example>

      <para>This example is a model of a mass-action differential
      equation. In this example, the model has a &Stepper;
      <literal>ODE_1</literal> of class
      <classname>ODE45Stepper</classname>, which is a generic ordinary
      differential equation solver.  The model also has the root
      system (<literal>/</literal>).  The root sytem has the
      <property>StepperID</property> property, and four &Entity;
      objects, &Variable;s <literal>SIZE</literal>,
      <literal>S</literal> and <literal>P</literal>, and the &Process;
      <literal>E</literal>.  <literal>SIZE</literal> is a special name
      of the &Variable;, that determines the size of the compartment.
      If the compartment is three-dimensional, it means the volume of
      the compartment in [L] (liter).  That value is used to calculate
      concentrations of other &Variable;s.  These &Entity; objects
      have their property values of several different types.  For
      example, <literal>StepperID</literal> of the root system is the
      string without quotes (<literal>ODE_1</literal>). The initial
      value given to <property>Value</property> property of the
      &Variable; <literal>S</literal> is an integer number
      <literal>10000</literal> (and this is automatically converted to
      a real number <literal>10000.0</literal> when the &Variable;
      gets it because the type of the <property>Value</property>
      property is &Real;).  <property>Name</property> property of the
      &Process; <literal>E</literal> is the quoted string <literal>"A
      mass action from S to P"</literal>, and '<property>k</property>'
      of it is the real number <literal>1.0</literal>.
      <property>VariableReferenceList</property> property of
      <literal>E</literal> is the list of two lists, which contain
      strings (such as <literal>S0</literal>), and numbers (such as
      <literal>-1</literal>).  The list contain relative &FullID;s
      (such as <literal>:.:S</literal>) without quotes.</para>

    </sect2>


    <sect2>
      <title>General Syntax Of &EM;</title>

      <para>Basically an &EM; is (and thus an &EML; is) a list of just one
      type of directives: <emphasis>object instantiation</emphasis>.
      As we have seen, &ecell;'s simulation models have only two types 
      of 'objects'; &Stepper; and &Entity;.   After
      creating an object, property values of the object must be set.
      Therefore the object
      instantiation has two steps: (1) creating the object
      and (2) setting properties.</para>

      <sect3>
	<title>General form of object instantiation statements</title>

	<para>The following is the general form of definition
(instantiation) of an object in &EM;:

<programlisting>
TYPE CLASSNAME( ID )
"""INFO (<emphasis>optional</emphasis>)"""
{ 
        PROPERTY_NAME_1 PROPERTY_VALUE_1;
        PROPERTY_NAME_2 PROPERTY_VALUE_2;
        ...
        PROPERTY_NAME_n PROPERTY_VALUE_n;
} 
</programlisting>
where:
<itemizedlist>
	    <listitem>
	      <para>TYPE</para>
	      <para>The type of the object, which is one of the followings:
      <itemizedlist>
		  <listitem>
		    <para>&Stepper;</para>
		  </listitem>
		  <listitem>
		    <para>&Variable;</para>
		  </listitem>
		  <listitem>
		    <para>&Process;</para>
		  </listitem>
		  <listitem>
		    <para>&System;</para>
		  </listitem>
		</itemizedlist>
</para>
	    </listitem>

	    <listitem>
	      <para>ID</para>
	      <para>This is a <emphasis>StepperID</emphasis> if the
		object type is &Stepper;.  If it is &System;, put a
		&SystemPath; here.  Fill in an &EntityID; if it is
		a &Variable; or a &Process;.</para>
	    </listitem>

	    <listitem>
	      <para>CLASSNAME</para>

	      <para>The classname of this object.  This class must be
a subclass of the baseclass defined by <emphasis>TYPE</emphasis>.  For
example, if the <emphasis>TYPE</emphasis> is &Process;,
<emphasis>CLASSNAME</emphasis> must be a subclass of &Process;, such
as <classname>MassActionFluxProcess</classname>.</para>
	    </listitem>

	    <listitem>
	      <para>INFO</para>

	      <para>An annotation for this object. This field is
		optional, and is not used in the simulation.  A quoted
		single-line ("string") or a multi-line string
		("""multi-line string""") can be put here.</para>
	    </listitem>

	    <listitem>
	      <para>PROPERTY</para>

	      <para>An object definition has zero or more properties.</para> 

	      <para>The property starts with an unquoted property name
		string, followed by a property value, and ends with a
		semi-colon (<literal>;</literal>).  For example, if
		the property name is
		<property>Concentration</property> and the value is
		<literal>10.0</literal>, it may look like:
		<informalexample>
		  <programlisting>Concentration 10.0;</programlisting></informalexample></para>

	      <para>&Real;, &Integer;, &StringType;, and List are
		allowed as property value types (See the Object Properties
		section above).</para> 

	      <para>If the value is a List, outermost
		brackets are omitted.  For example, to put a list
		<programlisting>[ 10 "string" [ LIST ] ]</programlisting> 
                into a property slot <literal>Foo</literal>, write a
		line in the object definition like this:
<informalexample>
		  <programlisting>Foo 10 "string" [ LIST ];</programlisting>
		</informalexample>
<note>
		  <title>Why the outermost brackets can be ommited?</title> 

		  <para>All property values are lists, even if it is
		    a scalar &Real; number.  Remember a number '1.0' is
		    interconvertible with a length-1 list '[ 1.0 ]'. 
                    Therefore the system can correctly interpret property
                    values without the brackets.
                    </para>

		  <para>In other words, if the property value is
		    bracketed, for example, the following property value
<programlisting>Foo [ 10 [ LIST ] ];</programlisting> 
                    is interpreted by the system as a length-1 List 
<programlisting>[ [ 10 [ LIST ] ] ]</programlisting> 
                    of which the first item is a list
<programlisting>[ 10 [ LIST ] ]</programlisting> 
                    This may or may not be what you intend to have.</para>
		</note>
</para>

	    </listitem>

	  </itemizedlist>



</para>

      </sect3>
    </sect2>

    <sect2>
      <title>Macros And Preprocessing</title>

      <para>Before converting to &EML;,
         <command>ecell3-em2eml</command> command invokes the &empy;
         program to preprocess the given &EM; file.
        </para>

      <para>By using &empy;, you can embed any &Python;
	expressions and statements after '@' in an &EM; file.  Put
	a &Python; expression inside '@( <replaceable>python expression</replaceable> )', and the
	macro will be replated with an evaluation of the expression.
	If the expression is very simple, '()' can be ommited. Use '@{
	<replaceable>pytyon statements</replaceable> }' to embed &Python; statements.  For
	example, the following code:

<programlisting>@(AA='10')
@AA</programlisting> is expanded to:
	<programlisting>10</programlisting>

        Of course the statement can be multi-line.  This code 

<programlisting>
@{
  def f( str ):
      return str + ' is true.'
}

@f( 'Video Games Boost Visual Skills' )
</programlisting>

        is expanded to

<programlisting>Video Games Boost Visual Skills is true.</programlisting>
</para>

      <para>&empy; can also be used to include other files.  The
following line is replaced with the content of the file
<filename>foo.em</filename> immediately before the &EM; file is
converted to an &EML;: 

<programlisting>@include( 'foo.em' )</programlisting>
</para>

      <para>Use <option>-E</option> option of
	<command>ecell3-em2eml</command> command to see what happens
	in the preprocessing.  With this option, it outputs the result of the
	preprocessing to standard output and stops without creating an
	&EML; file.</para>

      <para>It has many more nice features.  See the appendix A
	for the full description of the &empy; program.</para>
    </sect2>

    <sect2>
      <title>Comments</title>

      <para>The comment character is a sharp '#'.  If a line contains
         a '#' outside a quoted-string, anything after the character
         is considered a comment, and not processed by the
         <command>ecell3-em2eml</command> command.</para>

      <para>This is processed differently from the &empy; comments
         (@#).  This comment character is processed by the &empy; as a
         usual character, and does not have an effect on the
         preprocessor.  That is, the part of the line after '#' is not
         ignored by &empy; preprocessor.   To comment out an &empy; macro, 
         the &empy; comment (@#) must be used.
         </para>
    </sect2>

  </sect1>

  <sect1>
    <title>Structure Of The Model</title>

    <sect2>
      <title>Top Level Elements</title>

      <para>Usually an &EM; has one or more &Stepper; and one or more &System;
	statements.  These statements are top-level elements of the file.
        General structure of an &EM; file may look like this:
<programlisting>
STEPPER_0
STEPPER_1
...
STEPPER_n

SYSTEM_0 # the root system ( '/' )
SYSTEM_1
...
SYSTEM_m
</programlisting>

        <literal>STEPPER_?</literal> is a &Stepper; statement and 
        <literal>SYSTEM_?</literal> is a &System; statement.
</para>

    </sect2>

    <sect2>

      <title>Systems</title>

      <sect3>
	<title>The root system</title>
	
	<para>The model must have a &System; with a
	 &SystemPath; '<literal>/</literal>'.  This &System; is called
	 the <emphasis>root system</emphasis> of the model.

<programlisting>
System System( / )
{
    # ...
}
</programlisting>
</para>

	<para>The class of the root system is always
         <classname>System</classname>, no matter what
         class you specify.  This is because the simulator creates the
         root sytem when it starts up, before loading the model
         file. That is, the statement does not actually create the
         root system object when loading the &EML; file, but just set
         its property values.  Consequently the class name specified
         in the &EML; is ignored.  The model file must always have
         this root system statement, even if you have no property to
         set.
      </para>

      </sect3>

      <sect3>
	<title>Constructing the system tree</title>

	<para>If the model has more than one &System; objects, it must
         form a tree which starts from the root system (/).  For
         example, the following is <emphasis>not</emphasis> a valid &EM;.

<programlisting>
System System( / )
{
}

System System( /CELL0/MITOCHONDRION0 )
{
}
</programlisting>

         This is invalid because these two &System; objects,
         <literal>/</literal> and
         <literal>/CELL0/MITOCHONDRION0</literal> are not connected to
         each other, nor form a single tree.  Adding another &System;,
         <literal>/CELL0</literal>, makes it valid.

<programlisting>
System System( / )
{
}

System System( /CELL0 )
{
}

System System( /CELL0/MITOCHONDRION0 )
{
}
</programlisting>

         Of course a &System; can have arbitrary number of sub-systems.

<programlisting>
System System( / )
{
}

System System( /CELL1 ) {}
System System( /CELL2 ) {}
System System( /CELL3 ) {}
# ...
</programlisting>

</para>


	<note>
	  <title>Planned support for model composition</title>

	  <para>In future versions, the system will support composing
             a model from multiple model files (&EM;s or &EML;s).
             This is not the same as the &EM;'s file inclusion by
             &empy; preprocessor.</para>
	</note>

      </sect3>


      <sect3>
	<title>Sizes of the Systems</title>

	<para>If you want to define the size of a &System;, create a
         &Variable; with an ID '<literal>SIZE</literal>'.  If the
         &System; models a three-dimensional compartment, the
         <literal>SIZE</literal> here means the volume of that
         compartment.  The unit of the volume is [L] (liter).  In the
         next example, size of the root system is
         <literal>1e-18</literal>.

<programlisting>System System( / )
{
    Variable Variable( SIZE )    # the size (volume) of this compartment
    {
        Value   1e-18;
    }
}</programlisting>
        </para>
	
	<para>If a System has no '<literal>SIZE</literal>' &Variable;,
         then it shares the <literal>SIZE</literal> &Variable; with
         its supersystem.  The root system always has its SIZE
         &Variable;.  If it is not given by the model file, then the
         simulator automatically creates it with the default value
         1.0.  The following example has four &System; objects, and
         two of them (<literal>/</literal> and
         <literal>/COMPARTMENT</literal>) have their own
         <literal>SIZE</literal> variables.  Remaining two
         (<literal>/SUBSYSTEM</literal> and its subsystem
         <literal>/SUBSYSTEM/SUBSUBSYSTEM</literal>) share the
         <literal>SIZE</literal> &Variable; with the root system.


<programlisting>
System System( / )                       # SIZE == 1.0 (default)
{
    # no SIZE
}

System System( /COMPARTMENT )            # SIZE == 2.0e-15
{
    Variable Variable( SIZE )
    {
        Value 2.0e-15
    }
}

System System( /SUBSYSTEM )              # SIZE == SIZE of the root sytem
{
    # no SIZE
}

System System( /SUBSYSTEM/SUBSUBSYSTEM ) # SIZE == SIZE of the root system
{
    # no SIZE
}
</programlisting>
</para>

	<note>
	  <title>SIZE must be a positive real number</title>
	  <para>Behavior of the system when zero or negative number is
	  set to SIZE is undefined.</para>
	</note>

	<note>
	  <title>Unit of the size</title> <para>Currently, the unit of
	  the SIZE is (10 cm)^<emphasis>d</emphasis>, where d is dimension
	  of the &System;.  If d is 3, it is (10 cm)^3 == liter.  This
	  specification is still under discussion, and is subject to
	  change in future versions.</para>
	</note>
      </sect3>



    </sect2>

    <sect2>
      <title>Variables And Processes</title>

      <para>A &System; statement has zero, one or more &Variable; and
	&Process; statements in addition to its properties.

<programlisting>
System System( / )
{
    # ... properties of this System itself comes here..

    Variable Variable( V0 ) {}
    Variable Variable( V1 ) {}
    # ...
    Variable Variable( Vn ) {}

    Process SomeProcess( P0 )  {}
    Process SomeProcess( P1 )  {}
    # ...
    Process OtherProcess( Pm ) {}
}
</programlisting>

      Do not put a &System; statement inside &System;.
</para>
    </sect2>



    <sect2>
      <title>Connecting Steppers With Entity Objects</title>

      <para>Any &Process; and &Variable; object in the model must be
         connected with a &Stepper; by setting its
         <property>StepperID</property> property.  If the
         <property>StepperID</property> of a &Process; is omitted, it
         defaults to that of its supersystm (the &System; the &Process;
         belongs to).  <property>StepperID</property> of &System; cannot
         be omitted.</para>

      <para>In the following example, the root sytem is connected to
         the &Stepper; <literal>STEPPER0</literal>, and the &Process;
         <literal>P0</literal> and <literal>P1</literal> belong to
         &Stepper;s <literal>STEPPER0</literal> and
         <literal>STEPPER1</literal>, respectively.

<programlisting>
Stepper SomeClassOfStepper( STEPPER0 )    {}
Stepper AnotherClassOfStepper( STEPPER1 ) {}

System System( / )  # connected to STEPPER0
{
    StepperID     STEPPER0;

    Process AProcess( P0 )     # connected to STEPPER0
    {
        # No StepperID specified.
    }

    Process AProcess( P1 )     # connected to STEPPER1
    {
        StepperID     STEPPER1;
    }
}
</programlisting>
</para>

      <para>Connections between &Stepper;s and &Variable;s are
	automatically determined by the system, and cannot be
	specified manually.  See the next section.</para>

    </sect2>

    <sect2>
      <title>Connecting Variable Objects With Processes</title>

      <para>A &Process; object changes values of &Variable;
         object(s) according to a certain procedure, such as the law
         of mass action.  What &Variable; objects the &Process; works
         on cannot be determined when it is programmed, but it must be
         specified by the modeler when the &Process; takes part in the
         simulation.  
         <property>VariableReferenceList</property> property of the
         &Process; relates some &Variable; objects with the &Process;.</para>

      <para><property>VariableReferenceList</property> is a list of
         <emphasis>&VariableReference;s</emphasis>.  A
         &VariableReference;, in turn, is usually a list of the
         following four elements:

<programlisting>[ <replaceable>reference_name</replaceable> <replaceable>FullID</replaceable> <replaceable>coefficient</replaceable> <replaceable>accessor_flag</replaceable> ]</programlisting>
         The last two fields can be omitted:         

<programlisting>[ <replaceable>reference_name</replaceable> <replaceable>FullID</replaceable> <replaceable>coefficient</replaceable> ]</programlisting>

         or,

<programlisting>[ <replaceable>reference_name</replaceable> <replaceable>FullID</replaceable> ]</programlisting>

          These elements have the following meanings.

<orderedlist>
	  <listitem>
	    <para>Reference name</para>

	    <para>This field gives a local name inside the &Process;
               to this &VariableReference;.  Some &Process; classes
               use this name to identify particular instances of
               &VariableReference;.</para>

	    <para>Currently, this reference name must be set for all
               &VariableReference;s, even if the &Process; does not
               use the name at all.
               </para>

	    <para>Lexical rule for this field is the same
               as the &EntityID;; leading alphabet or '_' with
               trailing alphabet, '_', and numeric characters.</para>
	  </listitem>

	  <listitem>
	    <para>&FullID;</para>

	    <para>This &FullID; specifies the &Variable; that this
               &VariableReference; points to.</para>

	    <para>The &SystemPath; of this &FullID; can be relative.
	       Also, &EntityType; can be omitted.   That is, writing
               like this is allowed:

<programlisting>:.:S0</programlisting>

             instead of

<programlisting>Variable:/CELL:S0</programlisting>

             , if the &Process; exists in the &System; <literal>/CELL</literal>.
</para>

	  </listitem>

	  <listitem>
	    <para>Coefficient (<emphasis>optional</emphasis>)</para>

	    <para>This coefficient is an integer value that defines
               weight of the connection between the &Process; and the
               &Variable; that this &VariableReference; points to.
              </para>

	    <para>If this value is a non-zero integer, then this
               &VariableReference; is said to be a <emphasis>mutator
               &VariableReference;</emphasis>, and the &Process; can
               change the value of the &Variable;.  If the value is zero,
               this &VariableReference; is not a mutator, and the &Process;
               should not change the value of the &Variable;.
               </para>

	    <para>If the &Process; represents a chemical reaction,
               this value is usually interpreted by the &Process; as a
               stoichiometric constant.  For example, if the
               coefficient is -1, the value of the &Variable; is
               decreased by 1 in a single occurence of the forward
               reaction.</para>

	    <para>If omitted, <emphasis>this field defaults to
	      zero</emphasis>.</para>
	  </listitem>

	  <listitem>
	    <para><emphasis>isAccessor</emphasis> flag (<emphasis>optional</emphasis>)</para>

	    <para>This is a binary flag; set either 1 (true) or 0 (false).  If
               this <emphasis>isAccessor</emphasis> flag is false, it
               indicates that the behavior of &Process; is not
               affected by the &Variable; that this
               &VariableReference; points to.  That is, the &Process;
               never reads the value of the &Variable;. The &Process;
               may or may not change the &Variable; regardless of the value
               of this field.</para>

            <para>Some &Process; objects automatically sets this
               information, if it knows it never changes
               the value of the &Variable; of this
               &VariableReference;.  Care should be taken when you set
               this flag manually, because many &Process; classes do
               not check this flag when actually read the value of the
               &Variable;.
             </para>

	    <para><emphasis>The default is 1 (true).</emphasis> This
               field is often omitted.</para>

	    <note>
	      <title>How isAccessor flag is used in the
		simulation</title> <para>In multi-stepper simulations,
		this information sometimes helps the system to run
		efficiently.  If the system knows, for example, all
		&Process; objects in the &Stepper; <literal>A</literal>
		do not change any &Variable; connected to the other
		&Stepper; <literal>B</literal>, it can give
		<literal>B</literal> more chance to have larger stepsizes,
		rather than always checking whether &Stepper;
		<literal>A</literal> changed some of the &Variable; objects. 
                This flag is mainly used when there are more than one
                &Stepper;s.</para>
	    </note>

	  </listitem>
	</orderedlist>

	</para>

      <para>
	 Consider a reaction &Process; in the root system,
	 <literal>R</literal>, consumes the &Variable;
	 <literal>S</literal> and produces the &Variable;
	 <literal>P</literal>, taking <literal>E</literal> as the
	 enzyme.  This class of &Process; requires to give the enzyme
	 as a &VariableReference; of name <literal>ENZYME</literal>.
	 All the &Variable; objects are in the root system. In &EM;,
	 <property>VariableReferenceList</property> of this
	 &Process; may appear like this:

<programlisting>
System System( / )
{
    # ...
    Variable Variable( S ) {}
    Variable Variable( P ) {}
    Variable Variable( E ) {}

    Process SomeReactionProcess( R )
    {
        # ...
        VariableReferenceList [ S0     :.:S -1 ]
                              [ P0     :.:P  1 ]
                              [ ENZYME :.:E  0 ];

    }
}
</programlisting>

</para>

    </sect2>

  </sect1>

  <sect1>
    <title>Modeling Schemes</title>
    
    <para>&ecell; is a multi-algorithm simulator.  It can run any kind
     of simulation algorithms, both discrete and continuous, and these
     simulation algorithms can be used in any combinations.   This
     section exlains how you can find appropriate set of object
     classes for your modeling and simulation projects.  This
     section does not give a complete list of available object classes
     nor detailed usage of those classes.  Read the chapter "Standard
     Dynamic Module Library" for more info.</para>

    <sect2>
      <title>Discrete Or Continuous ?</title>

      <para>&ecell; can model both discrete and continuous processes,
       and these can be mixed in simulation.  The system models
       discrete and continuous systems by discriminating two different
       types of &Process; and &Stepper; objects: discrete &Process; /
       &Stepper; and continuous &Process; / &Stepper;.</para>

      <note>
	<title>Variable is discrete and continous</title>

	<para>&Variable; and &System; do not have special discrete and
      continuous classes.  The base &Variable; class supports both
      discrete and continous operations, because it can be connected
      to any types of &Process; and &Stepper; objects.  &System;
      objects do not do any computation that needs to discriminate
      discrete and continuos.</para>
      </note>




      <sect3>
	<title>Discrete classes</title>

	<para>A &Process; object that
       models discrete changes of one or more &Variable; objects is called a
       <emphasis>discrete &Process;</emphasis>, and it must be used in
       conjunction with a <emphasis>discrete &Stepper;</emphasis>.  A
       discrete &Process; directly changes the <emphasis>values</emphasis> of
       related &Variable; objects when its &Stepper; requests to do so.
</para>


      <para>There are two types of discrete &Process; / &Stepper;
       classes: discrete and discrete event.</para>

      <itemizedlist>
	<listitem>
	  <para>Discrete</para>

	  <para>A discrete &Process; changes values of connected
	  &Variable; objects (i.e. appear in its
	  <property>VariableReferenceList</property> property)
	  discretely.  In the current version, there is no special
	  class named <classname>DiscreteProcess</classname>, because
	  the base &Process; class is already a discrete &Process; by
	  default. The manner of the change of &Variable; values is
	  determined from values of its accessor &VariableReference;s,
	  its property values, and sometimes the current time of the
	  &Stepper;.  Unlike discrete event &Process;, which is
	  explained in the next item, it does not necessary specify
	  when the discrete changes of &Variable; values occur.
	  Instead, it is unilaterally determined and fired by a
	  discrete &Stepper;.</para>

	  <para>A &Stepper; that requires all &Process; objects
           connected is discrete &Process; objects is call a discrete
           &Stepper;.  The current version has no special class
           <classname>DiscreteStepper</classname>, because the base
           &Stepper; class is already discrete.</para>

	</listitem>


	<listitem>
	  <para>Discrete event</para>

	  <para>Discrete event is a special case of discreteness.  The
           system provides <classname>DiscreteEventStepper</classname>
           and <classname>DiscreteEventProcess</classname> classes for
           discrete-event modeling.  In addition to the ordinary
           firing method (<methodname>fire()</methodname> method)
           of the base &Process; class, the
           <classname>DiscreteEventProcess</classname> defines a
           method to calculate <emphasis>when</emphasis> is the next
           occurrence of the event (the discrete change of &Variable;
           values that this discrete event &Process; models) from
           values of its accessor &VariableReference;s, its property
           values, and the current time of the &Stepper;.
           <classname>DiscreteEventStepper</classname> uses
           information given by this method to determine when each of
           discrete event &Process; should be fired.
           <classname>DiscreteEventStepper</classname> is
           instantiatable.  See the chapter
           Standard Dynamic Module Library for more detailed
           description of how
           <classname>DiscreteEventStepper</classname> works.</para>

	</listitem>
      </itemizedlist>

      </sect3>

      <sect3>
	<title>Continuous classes</title>

	<para>On the other hand, a &Process; that calculates continuous
       changes of &Variable; objects is called a <emphasis>continuous
       &Process;</emphasis>, and is used in combination with a
       <emphasis>continuous &Stepper;</emphasis>.  Continuous
       &Process; objects simulate the phenomena that represents by
       setting <emphasis>velocities</emphasis> of connected &Variable;
       objects, rather than directly changing their values in the case
       of discrete &Process; objects.  A continuous &Stepper;
       integrates the values of &Variable; objects from the velocities
       given by the continuous &Process; objects, and determines when
       the velocities should be recalculated by the &Process; objects.
       A typical application of continuous &Process; and &Stepper;
       objects is to implement differential equations and differential
       equation solvers, respectively, to form a simulation system
       of the system of differential equations.</para>
      </sect3>

    </sect2>


    <sect2>
      <title>Some Available Discrete Classes</title>

      <para>Followings are some available discrete classes.</para>


      <sect3>
	<title>NRStepper and GillespieProcess (Gillespie-Gibson pair)</title>

	<para>An example of discrete-event simulation method
           provided by &ecell; is a variant of Gillespie's stochastic
           algorithm, the Next Reaction Method, or Gillespie-Gibson
           algorithm.  <classname>NRStepper</classname> class
           implements this algorithm.  When this &Stepper; is 
           used in conjunction with <classname>GillespieProcess</classname>
           objects, which is a
           subclass of <classname>DiscreteEventProcess</classname> and
           calculates a time of the next occurence of the reaction
           using Gillespie's reaction probability equation and a
           random number, &ecell; conducts
           a Gillespie-Gibson stochastic simulation of elementary
           chemical reactions.
           In fact, the Next Reaction
           Method is nothing but a standard discrete event simulation
           algorithm, and <classname>NRStepper</classname> is just an
           alias of the <classname>DiscreteEventStepper</classname> class.
           </para>
           
	<para>Usage of this pair of classes of objects is simple: just
         set the <property>StepperID</property>,
         <property>VariableReferenceList</property> and the rate
         constant property <property>k</property> of those
         <classname>GillespieProcess</classname> objects.</para>
      </sect3>


      <sect3>
	<title>DiscreteTimeStepper</title>

	  <para>A type of discrete &Stepper; that is provided by the
           system is
           <emphasis><classname>DiscreteTimeStepper</classname></emphasis>.
           This class of &Stepper;, when instantiated, calls all
           discrete &Process; objects with a fixed user-specified
           time-interval.  For example, if the model has a
           <classname>DiscreteTimeStepper</classname> with 0.001
           (second) of <property>StepInterval</property> property, it
           fires all of its &Process; objects every milli-second.
           <classname>DiscreteTimeStepper</classname> is discrete time
           because it does not have time between steps; it ignores a
           signal from other &Stepper; objects (<emphasis>&Stepper;
           interruption</emphasis>) that notifies a change of system
           state (values of &Variable; objects) that may affect its
           &Process; objects.  Such a change is reflected in the next
           step.
            </para>
      </sect3>

      <sect3>
	<title>PassiveStepper</title>

	<para>Another class of discrete &Stepper; is
	<classname>PassiveStepper</classname>.  This can partially be 
	seen as a <classname>DiscreteTimeStepper</classname> with
	an infinite <property>StepInterval</property>, but there is a
	difference.  Unlike
	<classname>DiscreteTimeStepper</classname>, this does
	<emphasis>not</emphasis> ignore &Stepper; interruptions, which
	notify change in the system state that may affect this
	&Stepper;'s &Process; objects.</para>
	
	<para>This &Stepper; is used when some special procedures
         (coded in discrete &Process; objects) must be invoked when
         other &Stepper; object may have changed a value or a velocity
         of at least one &Variable; that this &Stepper;'s &Process; objects
         accesses.</para>

      </sect3>

      <sect3>
	<title>PythonProcess</title>

	<para><classname>PythonProcess</classname> allows users to
	  script a &Process; object in full &Python; syntax.</para>

	<para><methodname>initialize</methodname>() and
	<methodname>fire</methodname>() methods can be scripted with
	<property>InitializeMethod</property> and
	<property>FireMethod</property> properties, respectively.</para>

	<para><classname>PythonProcess</classname> can be either
	discrete or continuous.  This 'operation mode' can be specified
        by setting <property>IsContinuous</property> property.  The default
        is false (0), or discrete.   To switch to the continuous mode,
        set 1 to the property:
<programlisting>Process PythonProcess( PY1 )
{
    IsContinuous 1;
}</programlisting>
</para>
	
	<para>In addition to regular &Python; constructs, the
         following objects, methods, and attributes are available in
         both of the method properties
         (<property>InitializeMethod</property> and
         <property>FireMethod</property>):

<itemizedlist>
	    <listitem>
	      <para>Properties</para>

	      <para><classname>PythonProcess</classname> accepts
	       arbitrary names of properties.  For example, the following
               code creates two new properties.
<programlisting>Process PythonProcess( PY1 )
{
    NewProperty "new property";
    KK          3.0;
}</programlisting>
              These properties can be use in &Python; methods:
<programlisting>Process PythonProcess( PY1 )
{
    # ... NewProperty and KK are set

    InitializeMethod "print NewProperty";

    FireMethod '''
KK += 1.0
print KK 
''';
}</programlisting>
               A new property can also be created within &Python; methods.
<programlisting>
    InitializeMethod "A = 3.0"; # A is created
    FireMethod "print A * 2";   # A can be used here
</programlisting>
             These properties are treated as a global variable.
                </para>
	    </listitem>

	    <listitem>
	      <para>Objects</para>
	      <itemizedlist>
		<listitem>
		  <para><varname>self</varname></para>
		  <para>This is the &Process; object itself.  This has
			the following attributes:
<itemizedlist>

		      <listitem>
			<para><property>Activity</property></para>

			<para>The current value of
			<property>Activity</property> property of this
			&Process;.</para>
		      </listitem>

		      <listitem>
			<para><methodname>addValue</methodname>(
			<parameter>value</parameter> )</para>

			<para>Add each &VariableReference; the
			<parameter>value</parameter> multiplied by the
			coefficient of the &VariableReference;.</para>

			<para>Using this method implies that this
                         &Process; is discrete.
                         Check that <property>IsContinuous</property> property
                         is false.</para>
		      </listitem>

		      <listitem>
			<para><methodname>getSuperSystem</methodname>()</para>
			<para>This method gets the super system
			      of this &Process;.  See below for the
			      attributes of &System; objects.</para>
		      </listitem>

		      <listitem>
			<para><property>Priority</property></para>

			<para>The <property>Priority</property> property
                         of this &Process;.</para>
		      </listitem>


		      <listitem>
			<para><methodname>setFlux</methodname>(
			<parameter>value</parameter> )</para>

			<para>Add each &VariableReference;'s velocity the
			<parameter>value</parameter> multiplied by the
			coefficient of the &VariableReference;.</para>

			<para>Using this method implies that this
                         &Process; is continuous.
                         Check that <property>IsContinuous</property> property
                         is true.</para>
		      </listitem>
		      
		      <listitem>
			<para><property>StepperID</property></para>

			<para><property>StepperID</property> of this
			&Process;.</para>
		      </listitem>
		    </itemizedlist>
		  </para>
		</listitem>

		<listitem>
		  <para>&VariableReference;</para>
		  
		  <para>&VariableReference; instances given in
			the <property>VariableReferenceList</property>
			property of this &Process; can be used in the
			&Python; methods.  Each instance has the following 
                        attributes:
<itemizedlist>

		      <listitem>
			<para><methodname>addFlux</methodname>( <parameter>value</parameter> )</para>

			<para>Multiply the
			<parameter>value</parameter> by the
			<property>Coefficient</property> of this
			&VariableReference;, and add that to the
			&Variable;'s
			<property>velocity</property>.</para>
		      </listitem>

		      <listitem>
			<para><methodname>addValue</methodname>( <parameter>value</parameter> )</para>

			<para>Add the <parameter>value</parameter> to
			the <property>Value</property> property of the
			&Variable;.</para>
		      </listitem>

		      <listitem>
			<para><methodname>addVelocity</methodname>( <parameter>value</parameter> )</para>

			<para>Add the <parameter>value</parameter> to
			the <property>Velocity</property> property of
			the &Variable;.</para>
		      </listitem>

		      <listitem>
			<para>Coefficient</para> <para>The
			      coefficient of the &VariableReference;</para>
		      </listitem>

		      <listitem>
			<para><methodname>getSuperSystem</methodname>()</para>

			<para>Get the super system of the &Variable;.
			A &System; object is returned.</para>
		      </listitem>


		      <listitem>
			<para>MolarConc</para> 
			<para>The concentration of the &Variable; in
			      Molar [M].</para>
		      </listitem>

		      <listitem>
			<para>Name</para>

			<para>The name of the &VariableReference;.</para>
		      </listitem>


		      <listitem>
			<para>NumberConc</para> <para>The
			      concentration in number [ num / size of
			      the &Variable;'s super system. ]</para>
		      </listitem>

		      <listitem>
			<para>IsFixed</para>

			<para>Zero if the <property>Fixed</property>
			property of the &Variable; is false.
			Otherwise a non-zero integer.</para>
		      </listitem>

		      <listitem>
			<para>IsAccessor</para>

			<para>Zero if the <property>IsAccessor</property>
			flag of the &VariableReference; is false.
			Otherwise a non-zero integer.</para>
		      </listitem>

		      <listitem>
			<para>TotalVelocity</para>

			<para>The total current velocity.
			      Usually of no use.</para>
		      </listitem>

		      <listitem>
			<para>Value</para>
			<para>The value of the &Variable;</para>
		      </listitem>


		      <listitem>
			<para>Velocity</para>

			<para>The provisional velocity given by
			      the currently stepping &Stepper;.
			      Usually of no use.</para>
		      </listitem>
		    </itemizedlist>


</para>
		</listitem>

		<listitem>
		  <para>&System;</para>

		  <para>A &System; object has the following
			attributes.
<itemizedlist>

		      <listitem>
			<para><methodname>getSuperSystem</methodname>()</para>

			<para>Get the super system of the &System;.
			 A &System; object is returned.</para>
		      </listitem>


		      <listitem>
			<para><property>Size</property></para>
			<para>The size of the &System;.</para>
		      </listitem>

		      <listitem>
			<para><property>SizeN_A</property></para>
			<para>Equivalent to <literal>Size *
			N_A</literal>, where N_A is a Avogadro's
			number.</para>
		      </listitem>

		      <listitem>
			<para><property>StepperID</property></para>

			<para>The <property>StepperID</property> of the &System;.</para>
		      </listitem>


		    </itemizedlist>

</para>

		</listitem>
	      </itemizedlist>
	    </listitem>

	  </itemizedlist>

</para>

	<para>Here is an example uses of <classname>PythonProcess</classname>.
<example>
	    <title>An assignment rule by using PythonProcess</title>
	    <programlisting>
Process PythonProcess( PY1 )
{
    # IsContinuous 0; -- default
    FireMethod "S1.Value = S2.Value + S3.Value";
    VariableReferenceList [(S1)] [(S2)] [(S3)];
}
</programlisting>
	  </example>

</para>

      </sect3>

      <sect3>
	<title>PythonEventProcess</title>

	<para>This class enables users &Python; scripting of
         time-events.  In addition to
         <methodname>initialize</methodname>() and
         <methodname>fire</methodname>(),
         <methodname>updateStepInterval</methodname>() method can be
         scripted with this class.  Use
         <property>UpdateStepIntervalMethod</property> property to set
         this.</para>

	<para>In addition to those of
         <classname>PythonProcess</classname>, the
         <varname>self</varname> object of
         <classname>PythonEventProcess</classname> has some more
         attributes:

<itemizedlist>
	    <listitem>
	      <para><property>StepInterval</property></para>

	      <para>The most recent <property>StepInterval</property>
	      calculated by the
	      <methodname>updateStepInterval</methodname>()
	      method.</para>
	    </listitem>

	    <listitem>
	      <para><property>DependentProcessList</property></para>

	      <para>This attribute holds a tuple of IDs of dependent
	      &Process;es of this &Process;.</para>
	    </listitem>
	  </itemizedlist>
</para>


	<para>This class of objects must be used with a
	<classname>DiscreteEventStepper</classname>.</para>

	<para>This class is under development.</para>
      </sect3>

      <sect3>
	<title>Other discrete classes</title>

	<para>&Stepper; classes for explicit and implicit tau leaping
	algorithms are under development.
         </para>

	<para>A flux-distribution method for hybrid dynamic/static
         simulation of biochemical pathways is available with the
         following classes:
         <classname>FluxDistributionStepper</classname>,
         <classname>FluxDistributionProcess</classname>,
         <classname>QuasiDynamicFluxProcess</classname>.  Usage of
         this scheme is to be described.</para>
      </sect3>

    </sect2>



    <sect2>
      <title>Some Available Continuous Classes</title>

      <para>&ecell; supports both Ordinary Differential Equation (ODE)
       and Differential-Algebraic Equation (DAE) models, and has
       &Stepper; classes for each type of formalisms.</para>

      <para>Also, the system is shipped with some continuous &Process;
       classes.  For example,
       <classname>MassActionFluxProcess</classname> calculates a
       reaction rate according to the law of mass action.
       <classname>ExpressionFluxProcess</classname> allows users to
       describe arbitrary rate equations in model files.
       <classname>PythonProcess</classname> and
       <classname>PythonFluxProcess</classname> are used to script
       &Process; objects in &Python;. Some enzyme kinetics rate laws
       are also available.</para>

      <sect3>
	<title>Generic ordinary differential Steppers</title>

	<para>If your model is a system of ODEs, then in this version
of the software (version &appversion;) the recommended choice is
<classname>ODE45Stepper</classname>.  A current drawback of this
&Stepper; is that it is not good at solving stiff systems.  In near
future, a high-performance replacement of this,
<classname>ODEStepper</classname>, will be included.</para>


	<para>Some other available ODE &Stepper; classes are
	<classname>ODE23Stepper</classname>, which employes a lower
	(the second) order integration algorithm, and
	<classname>FixedODE1Stepper</classname> that implements the
	simplest Euler algorithm without an adaptive step sizing
	mechanism.</para>

	<para>These ODE &Stepper; classes except for the
	<classname>FixedODE1Stepper</classname> have some common
	property slots for user-specifiable parameters.  Here is a
	partial list:

<itemizedlist>
	    <listitem>
	      <para><property>Tolerance</property></para> 

	      <para>An error tolerance in local truncation error.  Giving
	      this smaller numbers forces the &Stepper; to take
	      smaller step sizes, and slows down the simulation.
	      Greater numbers results in faster run with
	      sacrifice of accuracy.  A typical number is 1e-6.</para>
	    </listitem>

	    <listitem>
	      <para><property>MinStepInterval</property> / <property>MaxStepInterval</property></para>

	      <para>Minimum and maximum limits in step size.  These limits
	      preceeds the <property>Tolerance</property> property
	      above.</para>

	      <para>These properties can also be useful to completely
	      disable the adaptive step size control mechanism: set
	      the same number to both of the property slots.</para>
	    </listitem>
	  </itemizedlist>
</para>


      </sect3>

      <sect3>
	<title>MassActionFluxProcess</title>
	
	<para><classname>MassActionFluxProcess</classname> is a class
	 of &Process; for simple mass-actions.  This class calculates
	 a flux rate according to the irreversible mass-action.  Use a
	 property <property>k</property> to specify a rate
	 constant.</para>

	</sect3>

      <sect3>
	<title>ExpressionFluxProcess</title>
	
	<para><classname>ExpressionFluxProcess</classname> is designed
         for easy and efficient representations of continuous flux
         rate equations.</para>

	<para><property>Expression</property> property of this class
	  accepts a plain text rate expression.  The expression must
	  be evaluated to give a flux rate in [ number / second ].
	  (Note that this is a number per second, not concentration
	  per second.)  Here is an example use of
	  <classname>ExpressionFluxProcess</classname>:
<programlisting>
Process ExpressionFluxProcess( P1 )
{
    k 0.1;
    Expression "k * S.Value";

    VariableReferenceList [ S :.:S -1 ] [ P :.:P 1 ];
}</programlisting>

</para>

	<para>Compared to <classname>PythonProcess</classname> or
         <classname>PythonFluxProcess</classname> below, it runs
         significantly faster with sacrifice of some flexibility in
         scripting.</para>

	<para>The following shows elements those can be used in the
	 <property>Expression</property> property.  The set of
	  available arithmetic operators and mathematical
	  functions are meant to be equivalent to SBML level 2, except
          control structures.

<itemizedlist>
		  <listitem>
		    <para>Constants</para>
		    <para>Numbers (e.g. 10, 10.33, 1.33e-5), 
<constant>true</constant>,
<constant>false</constant> (equivalent to zero),
<constant>pi</constant> (Pi),
<constant>NaN</constant> (Not-a-Number),
<constant>INF</constant> (Infinity),
<constant>N_A</constant> (Avogadro's number),
<constant>exp</constant> (the base of natural logarithms).</para>
		  </listitem>

		  <listitem>
		    <para>Arithmetic operators</para>
		    <para>
<literal>+</literal>, <literal>-</literal>, <literal>*</literal>,
<literal>/</literal>, <literal>^</literal> (power; this can
equivalently be written as <literal>pow( x, y )</literal>).
</para>
		  </listitem>

		  <listitem>
		    <para>Built-in functions</para>
		    <para>
<function>abs</function>, <function>ceil</function>,
<function>exp</function>, *<function>fact</function>,
<function>floor</function>, <function>log</function>,
<function>log10</function>, <function>pow</function>
<function>sqrt</function>, *<function>sec</function>,
<function>sin</function>, <function>cos</function>,
<function>tan</function>, <function>sinh</function>,
<function>cosh</function>, <function>tanh</function>,
<function>coth</function>, *<function>csch</function>,
*<function>sech</function>, *<function>asin</function>,
*<function>acos</function>, *<function>atan</function>,
*<function>asec</function>, *<function>acsc</function>,
*<function>acot</function>, *<function>asinh</function>,
*<function>acosh</function>, *<function>atanh</function>,
*<function>asech</function>, *<function>acsch</function>,
*<function>acoth</function>.  (Functions with astarisk '*' are
currently not available on the Windows version.)
</para>
		    <para>All functions but <function>pow</function> are unary functions. <function>pow</function> is a binary function.</para>
		  </listitem>

	    <listitem>
	      <para>Properties</para>

	      <para>Similar to <classname>PythonProcess</classname>,
		<classname>ExpressionFluxProcess</classname>
		accepts arbitrary name properties in the model.
                Unlike <classname>PythonProcess</classname>, however,
                these properties of this class can hold only &Real; values.
		 </para>
		  </listitem>

		  <listitem>
		    <para>Objects</para>
		    <itemizedlist>
		      <listitem>
			<para><varname>self</varname></para>
			<para>This &Process; object itself.  This has
			the following attribute which is a sub set of
			that of <classname>PythonProcess</classname>:
<itemizedlist>
			    <listitem>
			      <para><methodname>getSuperSystem</methodname>()</para>
			    </listitem>
			  </itemizedlist>

</para>
		      </listitem>
		      <listitem>
			<para>&VariableReference;</para>

			<para>&VariableReference; instances given in
			the <property>VariableReferenceList</property>
			property of this &Process; can be used in the
			expression.  Each instance has the following 
                        set of attributes, which is a sub set of
                        that of <classname>PythonProcess</classname>:
<itemizedlist>
			    <listitem>
			      <para>Value</para>
			    </listitem>
			    <listitem>
			      <para>MolarConc</para> 
			    </listitem>
			    <listitem>
			      <para>NumberConc</para>
			    </listitem>
			    <listitem>
			      <para>TotalVelocity</para>
			    </listitem>
			    <listitem>
			      <para>Velocity</para>
			    </listitem>
			  </itemizedlist>


</para>
		      </listitem>

		      <listitem>
			<para>&System;</para>

			<para>A &System; object has the following two
			attributes.
<itemizedlist>
			    <listitem>
			      <para><property>Size</property></para>
			    </listitem>
			    <listitem>
			      <para><property>SizeN_A</property></para>
			    </listitem>
			  </itemizedlist>

</para>

		      </listitem>
		    </itemizedlist>
		  </listitem>


		</itemizedlist>
</para>

	<para>Below is an example of the basic
	      Michaelis-Menten reaction programmed with the
	      <classname>ExpressionFluxProcess</classname>.

<example>
		  <title>Michaelis-Menten reaction with ExpressionFluxProcess</title>
		  <programlisting>
Process ExpressionFluxProcess( P )
{
    Km    1.0;
    Kcat  10;

    Expression "E.Value * Kcat * S.MolarConc / ( S.MolarConc + Km )";

    VariableReferenceList [ S :.:S -1 ] [ P :.:P 1 ] [ E :.:E 0 ];
}</programlisting>
		</example>
</para>



      </sect3>
      

      <sect3>
	<title>Some pre-defined reaction rate classes</title>

	      <para>See the standard dynamic module library reference
	      for availability of some enzyme kinetics &Process;
	      classes.</para>

      </sect3>

      <sect3>
	<title>PythonFluxProcess</title>
	
	<para><classname>PythonFluxProcess</classname> is almost the
         same as <classname>PythonProcess</classname>, except that (1)
         it takes just a &Python; expression (instead of statements)
         to its <property>Expression</property> property, and (2)
         similar to <classname>ExpressionFluxProcess</classname>, the
         evaluated value of the expression is implicitly passed to the
         <methodname>setFlux</methodname>() method.</para>
      </sect3>


      <sect3>
	<title>Generic differential-algebraic Steppers</title>

	<para>For DAE models, use <classname>DAEStepper</classname>.
         The model must form a valid index-1 DAE system.  When a DAE
         &Stepper; detects one or more discrete &Process; objects, it
         assumes that these are <emphasis>algebraic
         &Process;</emphasis> objects.  Thus, all discrete &Process;
         objects in a DAE &Stepper; must be algebraic.  See below for
         what is algebraic &Process;.</para>

	<note>
	  <title>DAE &Stepper; objects can be used for ODE systems</title>

	  <para>
	  Because it can be viewed that ODE is a special case of DAE
	  problems which does not have a algebraic equations, but only
	  differential equations, a DAE &Stepper; can be used to run
	  an ODE model.  However, ODE Steppers are specialized for ODE
	  problems, in terms of both the selection of integration
	  algorithms and implementation issues, and generally use of
	  an ODE &Stepper; benefits in performance when the model is a
	  system of ODEs.</para>
	</note>

	<para>Those properties of ODE &Stepper; classes described above
         (such as the <property>Tolerance</property> property)
         are also available for DAE &Stepper; classes.</para>

      </sect3>

      <sect3>
	<title>Algebraic Processes</title>

	<para>This is a type of discrete &Process;, but placed here
         because it is used with a DAE &Stepper;, which is continuous.</para>

	<para>In principle, continuous &Process; objects must be
	connected with continuous &Stepper; instances, and a discrete
	&Stepper; is assumed to take only discrete &Process;
	objects.   However, there are some exceptions.  One of such is
        the <emphasis>algebraic processes</emphasis>.
	Strangely enough, in DAE simulations, seemingly discrete
         algebraic equations are solved continuously in conjunction with
         other differential equations.</para>

	<para>Algebraic equations in &ecell; has the following form:
         <programlisting>0 = g( t, x )</programlisting>
         where t is the time and x is a vector of variable references.
        </para>

	<para>The DAE solver system of &ecell; uses
         <property>Activity</property> property of &Process; objects
         to represent the value of the algebraic function <literal>g(
         t, x )</literal>.  An algebraic &Process; must
         <emphasis>not</emphasis> change values of &Variable; objects
         explicitly.  The DAE &Stepper; does this job of finding a
         point where the equation <literal>g()</literal> holds.</para>

         <para>When modeling, be careful about coefficients of
          &VariableReference;s of an algebraic &Process;.  In most
          cases, simply set unities. The solver respects these
          numbers when solving the system.  For example, if the
          coefficient of <varname>A</varname> is zero, it does not
          change the variable when trying to find the solution, while
          it is used in the calculation of the equation.</para>

	<para>As a means of describing algebraic equations,
	<classname>ExpressionAlgebraicProcess</classname> is available.
	The usage is the same as <classname>ExpressionFluxProcess</classname>,
        except that the evaluation of its expression is interpreted as the
        value of the algebraic function <literal>g()</literal>.</para>

<para>The following examble describes an equation
<programlisting>
a * A + B = 10,  a = 1.5
</programlisting>
<example>
	  <title>A simple algebraic equation using ExpressionAlgebraicProcess</title>
	  <programlisting>
Stepper DAEStepper( DAE1 ) {}

Process ExpressionAlgebraicProcess( P )
{
    StepperID DAE1;

    a    1.5;

    Expression "( a * A + B ) - 10";

    VariableReferenceList [ A :.:A 1 ] [ B :.:B 1 ];
}
</programlisting>
	  </example>
</para>

	<para>To use C++ or <classname>PythonProcess</classname> for
         algebraic equations, call
         <methodname>setActivity</methodname>() method to set the
         value of the equation.   The following is an example with
         a <classname>PythonProcess</classname>:

<example>
	  <title>A simple algebraic equation using PythonProcess</title>
	  <programlisting>
Process PythonProcess( PY )
{
    a    1.5;

    FireMethod "self.setActivity( ( a * A + B ) - 10 )";

    VariableReferenceList [ A :.:A 1 ] [ B :.:B 1 ];
}
</programlisting>
	</example>

</para>


      </sect3>




      <sect3>
	<title>Power-law canonical DEs (S-System and GMA)</title>

	<para><classname>ESSYNSStepper</classname> supports S-System and
         GMA simulations by using the ESSYNS algorithm.  
	A <classname>ESSYNSStepper</classname> must be connected 
        with either a <classname>SSystemProcess</classname> or
	a <classname>GMAProcess</classname>.  Use
	<property>SSystemMatrix</property> or
	<property>GMAMatrix</property> property to set the system
	parameters.</para>

	<para>A sample model under the directory
	<filename>doc/sample/ssystem/</filename> gives an example
	usage.</para>

	<para>These modules are still under development. More
	descriptions to come....</para>

      </sect3>



    </sect2>


  </sect1>



  <sect1>
  <title>Modeling Convensions</title>

  <sect2>
  <title>Units</title>

      <para>
      In &app;, the following units are used.
         This standard is meant only for the simulator's internal
         representation, and any units can be used in the process of
         modeling.  However, it must be converted to these standard units
         before loaded by the simulator.

       <itemizedlist>

	  <listitem>
	    <para>Time</para>

	    <para>s (second)</para>
	  </listitem>

	  <listitem>
	    <para>Volume</para>
	    <para>L (liter)</para>
	  </listitem>

	  <listitem>
	    <para>Concentration</para>
	    <para>Molar concentration (M, or molar per L (liter), used for example in <property>MolarConc</property> property of a &Variable; object) or,</para>
	    <para>Number concentration (number per L (liter), <property>NumberConc</property> property of &Variable; has this unit).</para>
	  </listitem>
	</itemizedlist>


</para>
    </sect2>

  </sect1>



  

  </chapter>


<!--
Local Variables:
mode: sgml
sgml-parent-document: ("users-manual.xml" "book" "chapter")
End:
-->

