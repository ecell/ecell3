//::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
//
//        This file is part of E-Cell Simulation Environment package
//
//                Copyright (C) 1996-2002 Keio University
//
//::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
//
//
// E-Cell is free software; you can redistribute it and/or
// modify it under the terms of the GNU General Public
// License as published by the Free Software Foundation; either
// version 2 of the License, or (at your option) any later version.
// // E-Cell is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
// See the GNU General Public License for more details.
// 
// You should have received a copy of the GNU General Public
// License along with E-Cell -- see the file COPYING.
// If not, write to the Free Software Foundation, Inc.,
// 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
// 
//END_HEADER
//
// written by Koichi Takahashi <shafi@e-cell.org>,
// E-Cell Project.
//


#ifndef __DEFS_HPP
#define __DEFS_HPP
 
#if defined( __CYGWIN__ )
#define WIN32 __CYGWIN__
#endif /* __CYGWIN __ */

#if defined( WIN32 )
#if defined(_MSC_VER)
#define _USE_MATH_DEFINES
#if _MANAGED
/* suppress __fastcall warnings */
#pragma warning(disable:4561)
#endif /* _MANAGED */
/* suppress deprecation warnings */
#pragma warning(disable:4996)
/* suppress DLL import warnings */
#pragma warning(disable:4251)
#endif /* _MSC_VER */
#endif /* WIN32 */

#include <float.h>
#include <string>
#include <time.h>
#include <limits>
#include @STD_MATH_HEADER@

#define ECELL_MAJOR_VERSION @ECELL_MAJOR_VERSION@
#define ECELL_MINOR_VERSION @ECELL_MINOR_VERSION@
#define ECELL_MICRO_VERSION @ECELL_MICRO_VERSION@
#define ECELL_VERSION_STRING @ECELL_VERSION_STRING@

@INT64_T_DECLARATION@
@ECELL_HAVE_UNORDERED_MAP@
@ECELL_HAVE_TR1_UNORDERED_MAP@
@ECELL_HAVE_PRETTY_FUNCTION_MACRO@
@ECELL_HAVE_FUNCTION_MACRO@
#define HIGHREAL_IS_REAL @HIGHREAL_IS_REAL@
#define HIGHREAL_TYPE @HIGHREAL_TYPE@
#define INF @INFINITY_VAL@

// 
// If USE_COMPILER_EXTENSIONS is defined, the compiler's special
// language syntax and optimizations that are not part of the standard
// (such as ISO C++) are exploited.
//
// Defined macros:
//
// LIBECS_USE_PMF_CONVERSIONS 
// If this macro is defined, conversions from pointer-to-member-functions 
// to usual function pointers can be used.
//
//
// LIBECS_LIKELY( EXP ), LIBECS_UNLIKELY( EXP )
// These macros indicate the expression EXP is very (un)likely to be true,
// and the branch based on this will be frequently (not) taken.
// These are typically used in if() statements.   Unless you are very sure,
// it is a good idea to not to try to do this job by yourself and just 
// rely on the compiler and CPU's branch prediction mechanisms and 
// profile-based branch counters. These macros do nothing when 
// libecs does not support branch prediction on the platform.
//
//
// LIBECS_PREFETCH( ADDR, RW, LOCALITY )
// This macro prefetches the content of memory at the address ADDR,
// and refreshes the cache.   If RW is zero, the cache is prepared for
// a read access, and one for a write access.  LOCALITY (0..3) indicates
// the temporal locality of the access.   Larger values let the
// accessed addresses more sticky on the cache.
// These macros do nothing when libecs does not support prefetching
// on the platform.
//

#if defined( USE_COMPILER_EXTENSIONS ) && defined( __GNUC__ )
#    define LIBECS_USE_PMF_CONVERSIONS 1
#    define LIBECS_LIKELY( EXP )       __builtin_expect( ( EXP ), 1 )
#    define LIBECS_UNLIKELY( EXP )     __builtin_expect( ( EXP ), 0 )
#    define LIBECS_PREFETCH( ADDR, RW, LOCALITY )\
            __builtin_prefetch( ( ADDR ), ( RW ), ( LOCALITY ) )
#else
// do not define LIBECS_USE_PMF_CONVERSIONS
#    define LIBECS_LIKELY( EXP )       ( EXP )
#    define LIBECS_UNLIKELY( EXP )     ( EXP )
#    define LIBECS_PREFETCH            
#endif /* defined( USE_COMPILER_EXTENSIONS ) && defined( __GNUC__ ) */

#if !defined( ECELL_HAVE_PRETTY_FUNCTION_MACRO )
#   if defined( ECELL_HAVE_FUNCTION_MACRO )
#       define __PRETTY_FUNCTION__  __FUNCTION__
#   else
#       define __PRETTY_FUNCTION__  ""
#   endif
#endif

// Some macros those origins are libCoreLinux++

/**
  IGNORE_RETURN is an indicator that the return
  value for a function is ignored.
  i.e   IGNORE_RETURN getSomething( ... );
  Eliminates a lint warning.
*/
#define IGNORE_RETURN (void)

/**
  Declare a new type and its pointer,
  const pointer, reference, and const reference types. For example
  DECLARE_TYPE( Dword, VeryLongTime );
  @param mydecl The base type
  @param mytype The new type
*/
#define DECLARE_TYPE( mydecl, mytype ) \
    typedef mydecl  mytype; \
    typedef mytype *       mytype ## Ptr; \
    typedef const mytype * mytype ## Cptr; \
    typedef mytype &       mytype ## Ref; \
    typedef const mytype & mytype ## Cref;

#define DECLARE_TYPE_2( mydecl, param2, mytype ) \
    typedef mydecl, param2  mytype; \
    typedef mytype *       mytype ## Ptr; \
    typedef const mytype * mytype ## Cptr; \
    typedef mytype &       mytype ## Ref; \
    typedef const mytype & mytype ## Cref;

#define DECLARE_TYPE_3( mydecl, param2, param3, mytype ) \
    typedef mydecl, param2, param3  mytype; \
    typedef mytype *       mytype ## Ptr; \
    typedef const mytype * mytype ## Cptr; \
    typedef mytype &       mytype ## Ref; \
    typedef const mytype & mytype ## Cref;

#define DECLARE_TYPE_4( decl, param2, param3, param4, mytype ) \
    typedef mydecl, param2, param3, param4  mytype;\
    typedef mytype *       mytype ## Ptr; \
    typedef const mytype * mytype ## Cptr; \
    typedef mytype &       mytype ## Ref; \
    typedef const mytype & mytype ## Cref;


/**
  Declare class , class pointer , 
  const pointer, class reference 
  and const class reference types for classes. For example
  DECLARE_CLASS( Exception );
  @param tag The class being declared
*/

#define DECLARE_CLASS( tag )            \
    class   tag;                        \
    typedef tag *       tag ## Ptr;     \
    typedef const tag * tag ## Cptr;    \
    typedef tag &       tag ## Ref;     \
    typedef const tag & tag ## Cref;

#define DECLARE_SHAREDPTR( type )\
  typedef ::boost::shared_ptr<type> type ## SharedPtr;\
  typedef type ## SharedPtr *       type ## SharedPtr ## Ptr;     \
  typedef const type ## SharedPtr * type ## SharedPtr ## Cptr;    \
  typedef type ## SharedPtr &       type ## SharedPtr ## Ref;     \
  typedef const type ## SharedPtr & type ## SharedPtr ## Cref;
/**
  STL list template. This macro generates all
  the type references and pointers for the collection and
  respective iterators for a list.
  @param name The name you want to give the collection
  @param type The type object the collection manages
*/
#define DECLARE_LIST( type, name )                            \
      DECLARE_TYPE(::std::list<type>,name);                     \
      DECLARE_TYPE(name::iterator, name ## Iterator);         \
      DECLARE_TYPE(name::const_iterator, name ## Iterator)    \
      DECLARE_TYPE(name::reverse_iterator, name ## Iterator);


/**
  STL vector template. This macro generates all
  the type references and pointers for the collection and
  respective iterators for a vector.
  @param name The name you want to give the collection
  @param type The type for the vector
*/
#define DECLARE_VECTOR( type, name )                         \
    DECLARE_TYPE(::std::vector<type>,name);                     \
    DECLARE_TYPE(name::iterator, name ## Iterator);           \
    DECLARE_TYPE(name::const_iterator, name ## ConstIterator);     \
    DECLARE_TYPE(name::reverse_iterator, name ## RIterator);

/**
  STL set template. This macro generates all
  the type references and pointers for the collection and
  respective iterators for a set.
  @param name The name you want to give the collection
  @param key The object that represents the set key
  @param comp The comparator functor
*/
#define DECLARE_SET(key, comp, name)                         \
    DECLARE_TYPE_2(::std::set< key, comp >, name);                \
    DECLARE_TYPE(name::iterator, name ## Iterator);           \
    DECLARE_TYPE(name::const_iterator, name ## ConstIterator)      \
    DECLARE_TYPE(name::reverse_iterator, name ## RIterator);
   
/**
  STL multiset template. This macro generates all
  the type references and pointers for the collection and
  respective iterators for a multiset.
  @param name The name you want to give the collection
  @param key The object that represents the mutliset key
  @param comp The comparator functor
*/
#define DECLARE_MULTISET(key, comp, name)                    \
    DECLARE_TYPE_2(::std::multiset< key, comp >, name);           \
    DECLARE_TYPE(::std::set< key, comp >, name);                \
    DECLARE_TYPE(name::iterator, name ## Iterator);           \
    DECLARE_TYPE(name::const_iterator, name ## ConstIterator);     \
    DECLARE_TYPE(name::reverse_iterator, name ## RIterator);

/**
  STL map template. This macro generates all
  the type references and pointers for the collection and
  respective iterators for a map.
  @param name The name you want to give the collection
  @param key The object that represents the map key
  @param value The object that the key is associated to
  @param comp The comparator functor
*/
#define DECLARE_MAP(key, value, comp, name)                 \
    DECLARE_TYPE_3(::std::map< key, value, comp >, name );       \
    DECLARE_TYPE(name::iterator, name ## Iterator);          \
    DECLARE_TYPE(name::const_iterator, name ## ConstIterator);    \
    DECLARE_TYPE(name::reverse_iterator, name ## RIterator);
   
/**
  STL multimap template. This macro generates all
  the type references and pointers for the collection and
  respective iterators for a multimap.
  @param name The name you want to give the collection
  @param key The object that represents the map key
  @param value The object that the key is associated to
  @param comp The comparator functor
*/

#define DECLARE_MULTIMAP(key, value, comp, name)            \
    DECLARE_TYPE_3(::std::multimap< key, value, comp >, name );  \
    DECLARE_TYPE(name::iterator, name ## Iterator);          \
    DECLARE_TYPE(name::const_iterator, name ## ConstIterator);    \
    DECLARE_TYPE(name::reverse_iterator, name ## RIterator);

/**
  STL queue template. This macro generates all
  the type references and pointers for the collection and
  respective iterators for a queue.
  @param name The name you want to give the collection
  @param type The type to be queued
*/
#define DECLARE_QUEUE( type, name )                          \
    DECLARE_TYPE(::std::deque< type >, name);  \
    DECLARE_TYPE(name::iterator, name ## Iterator);          \
    DECLARE_TYPE(name::const_iterator, name ## ConstIterator);    \
    DECLARE_TYPE(name::reverse_iterator, name ## RIterator);
/**
  STL stack template. This macro generates all
  the type references and pointers for the collection and
  respective iterators for a stack.
  @param name The name you want to give the collection
  @param type The type to be stacked
*/
#define DECLARE_STACK( type, name )                                 \
    DECLARE_TYPE(::std::stack<type>, name);

#define DECLARE_ASSOCVECTOR(key,value,comp,name)                 \
    DECLARE_TYPE_3(::Loki::AssocVector< key, value, comp >, name); \
    DECLARE_TYPE(name::iterator, name ## Iterator);          \
    DECLARE_TYPE(name::const_iterator, name ## ConstIterator);    \
    DECLARE_TYPE(name::reverse_iterator, name ## RIterator);

#if defined( ECELL_HAVE_UNORDERED_MAP )
#include <unordered_map>
#define UNORDERED_MAP( key, value, hasher ) \
    ::std::unordered_map< key, value, hasher >
#define DEFAULT_HASHER(key) ::std::hash<key>
#elif defined( ECELL_HAVE_TR1_UNORDERED_MAP )
#include <tr1/unordered_map>
#define UNORDERED_MAP( key, value, hasher ) \
    ::std::tr1::unordered_map< key, value, hasher >
#define DEFAULT_HASHER(key) ::std::tr1::hash<key>
#else
#include <map>
#define UNORDERED_MAP( key, value, hasher ) \
    ::std::map<key, value, hasher >
#define DEFAULT_HASHER(key) ::std::less<key>
#endif /* ECELL_HAVE_UNORDERED_MAP */

#define DECLARE_UNORDERED_MAP(key, value, hasher, name) \
    DECLARE_TYPE(UNORDERED_MAP( key, value, hasher ), name); \
    DECLARE_TYPE(name::iterator, name ## Iterator);          \
    DECLARE_TYPE(name::const_iterator, name ## ConstIterator);

#define  NULLPTR  0

// WIN32 stuff
#if defined( WIN32 )

#if defined( LIBECS_EXPORTS ) || defined( DLL_EXPORT )
#define LIBECS_API __declspec(dllexport)
#else
#define LIBECS_API __declspec(dllimport)
#endif /* LIBECS_EXPORTS */

#if !defined( __CYGWIN__ )
#define fmin(x, y) __min(x, y)
#endif /* __CYGWIN__ */

#else

#define LIBECS_API

#endif /* WIN32 */

#endif /* __DEFS_HPP */

/*
  Do not modify
  $Author: moriyoshi $
  $Revision: 2990 $
  $Date: 2008-01-19 16:36:03 +0900 (土, 19  1月 2008) $
  $Locker$
*/
