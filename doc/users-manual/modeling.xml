  <!-- ================ Writing em ================================ -->

  <chapter id="modeling"> 
  <title>Modeling with &ecell;</title> 

  <highlights>
    <para>By reading this chapter, you can get information about:</para>
    
    <simplelist>
      <member>How an &ecell;'s simulation model is organized.</member>
      <member>How to create a simulation model.</member>
      <member>How to write a model file in &EM; format.</member>
    </simplelist>
  </highlights>


  <sect1>
    <title>Objects In The Model</title>

    <para>
    &ecell;'s simulation model is fully object-oriented.  That is, the
    simulation model is actually a set of <emphasis>objects</emphasis>
    connected each other.  The objects have
    <emphasis>properties</emphasis>, which determine characteristics
    of the objects (such as a reaction rate constant if the object
    represent a chemical reaction) and relationships between
    the objects.
    </para>

    <sect2>
      <title>Types of the Objects</title>

      <para>A simulation model of &app; consists of the following types of objects.
<itemizedlist>
	  <listitem>
	    <para>Usually more than one &Entity; objects</para>
	  </listitem>
	  <listitem>
	    <para>One or more &Stepper; object(s)</para>
	  </listitem>
	</itemizedlist>
&Entity; objects define the structure of the simulation model and represented phenomena (such
as chemical reactions) in the model. &Stepper; objects
implement specific simulation algorithms.
</para>

    <sect3>
      <title>Entity objects</title>

      <para>
The &Entity; class has three subclasses:
<itemizedlist>
	  <listitem>
	    <para>&Variable</para> <para>This class of objects represent state
	  variables.  A &Variable; object holds a scalar real-number
	  value.  A set of values of all &Variable; objects in a
	  simulation model defines the state of the model at a certain
	  point in time.</para>
	  </listitem>
	  <listitem>
	    <para>&Process</para> <para>This class of objects
	  represent phenomena in the simulation model that result in
	  changes in the values of one or more &Variable; objects.
	  The way of change of the &Variable; values can be either
	  discrete or continuous.</para>
	  </listitem>
	  <listitem>
	    <para>&System</para> <para>This class of objects define
	  overall structure of the model.  A &System; object can
	  contain sets of these three types of &Entity;, &Variable;,
	  &Process;, and &System; objects.  A &System; can contain
	  other &System;s, and can form a tree-like structure.  
	  </para>
	  </listitem>
	</itemizedlist>
</para>

    </sect3>

      <sect3>
	<title>Stepper objects</title>
	
	<para>A model must have one or more &Stepper; object(s).  Each
      &Process; and &System; object must be connected with a &Stepper;
      object in the same model.  In other words, &Stepper; objects in
      the model have non-overlapping sets of &Process; and &System;
      objects.</para>
	
	<para>&Stepper; is a class which implement a specific simulation
      algorithm.  If the model has more than one &Stepper; objects,
      the system conducts a multi-stepper
      simulation.  In addition to the lists of &Process; and &System;
      objects, a &Stepper; has a list of &Variable; objects that can
      be read or written by its &Process; objects.  It also has a time
      step interval as a positive real-number.  The system schedules
      &Stepper; objects according to the step intervals, and updates
      the current time.</para>
	
	<para>When called by the system, a &Stepper; object integrates
      values of related &Variable; objects to the current time (if the
      model has a differential component), calls zero, one or more
      &Process; objects connected with the &Stepper; in an order
      determined by its implementation of the algorithm, and
      determines the next time step interval.  See the following
      chapters for details of the simulation procedure.</para>

    </sect3>

    </sect2>


    <sect2>
      <title>Object Identifiers</title>

      <para>&app; uses several types of identifier strings to specify
      the objects, such as the &Entity; and &Stepper; objects, in a
      simulation model.</para>

      <sect3>
	<title>ID (&EntityID; and &StepperID;)</title>

	<para>Every &Entity; and &Stepper; object has an
	<emphasis>ID</emphasis>.  ID is a character string of
	arbitrary length starting from an alphabet or '_' with
	succeeding alphabet, '_', and numeric characters.  &app treats
	IDs in a case-sensitive way.</para>

	<para>If the ID is used to indicate a &Stepper; object, it is
	called a &StepperID;.  The ID points to an &Entity; object is
	refered to as &EntityID;, or just
	<emphasis>ID</emphasis>.</para>

	<para>(need EBNF here)</para>

	<informalexample>
	  <para>Examples: <literal>_P3</literal>, <literal>ATP</literal>, <literal>GlucoKinase</literal></para>
	</informalexample>

      </sect3>

      <sect3>
	<title>SystemPath</title>

	<para>The &SystemPath; identifies a &System; from the
	tree-like hierarchy of &System; objects in a simulation model.
	It has a form of &EntityID; strings joined by a character '/'
	(slash).  As a special case, the &SystemPath; of the root
	system is <literal>/</literal>. For instance, if there is a
	&System; <literal>A</literal>, and <literal>A</literal> has a
	subsystem <literal>B</literal>, a &SystemPath;
	<literal>/A/B</literal> specifies the &System; object
	<literal>B</literal>.  It has three parts: (1) the root system
	(<literal>/</literal>), (2) the &System; <literal>A</literal>
	directly under the root system, and (3) the &System;
	<literal>B</literal> just under <literal>A</literal>.</para>

	<para>A &SystemPath can be relative.  The relative
	&SystemPath; does not point at a &System; object unless the
	current &System; is given.  A &SystemPath; is relative if (1)
	it does not start with the leading <literal>/</literal> (the
	root system), or (2) it contains '<literal>.</literal>' (the
	current system) or '<literal>..</literal>' (the super-system).
	</para>

	<informalexample>
	  <para>Examples: <literal>/A/B</literal>,
	  <literal>../A</literal>, <literal>.</literal>,
	  <literal>/CELL/ER1/../CYTOSOL</literal></para>
	</informalexample>

      </sect3>

      <sect3>
	<title>FullID</title>

	<para>A &FullID; (FULLy qualified IDentifier) identifies a
	unique &Entity; object in a simulation model.  A &FullID;
	comprises three parts, (1) a &EntityType;, (2) a &SystemPath;,
	and (3) an &EntityID;, joined by a character
	'<literal>:</literal>' (colon).

<programlisting><replaceable>EntityType</replaceable>:<replaceable>SystemPath</replaceable>:<replaceable>ID</replaceable></programlisting>

</para>

	<para>The &EntityType; is one of the following class names:
<itemizedlist>
	    <listitem>
	      <para>&System;</para>
	    </listitem>
	    <listitem>
	      <para>&Process;</para>
	    </listitem>
	    <listitem>
	      <para>&Variable;</para>
	    </listitem>
	  </itemizedlist>
</para>

	<para>For example, the following &FullID; points to a
&Process; object of which &EntityID; is '<literal>P</literal>', in the
&System; '<literal>CELL</literal>' immediately under the root system
(<literal>/</literal>).
<informalexample>
	    <programlisting>Process:/CELL:P</programlisting>
	  </informalexample>
</para>

      </sect3>

      <sect3>
	<title>FullPN</title>

	<para>&FullPN; (FULLy qualified Property Name) specifies a
	unique <emphasis>property</emphasis> (see the next section) of
	an &Entity; object in the simulation model.  It has a form of
	a &FullID; and the name of the property joined by a character
	'<literal>:</literal>' (colon).

<programlisting><replaceable>FullID</replaceable>:<replaceable>property_name</replaceable></programlisting>

        or,

<programlisting><replaceable>EntityType</replaceable>:<replaceable>SystemPath</replaceable>:<replaceable>ID</replaceable>:<replaceable>property_name</replaceable></programlisting>
</para>

	<para>The following &FullPN; points to 
	'<property>Value</property>' property of the &Variable; object
	<literal>Variable:/CELL:S</literal>.
<informalexample>
	    <programlisting>Variable:/CELL:S:Value</programlisting>
	  </informalexample>
</para>
      </sect3>

    </sect2>



    <sect2>
      <title>Object Properties</title>

      <para>&Entity; and &Stepper; objects have
      <emphasis>properties</emphasis>.  A property is an attribute of a
      certain object associated with a name.  Its value can be get from and
      set to the object.
      </para>

      <sect3>

	<title>Types of object properties</title>


	<para>A value of a property has a <emphasis>type</emphasis>,
      which is one of the followings.

<itemizedlist>
	    <listitem>
	      <para>&Real; number</para> 
	      <para>(ex. <literal>3.33e+10</literal>, <literal>1.0</literal>)</para>
	    </listitem>
	    <listitem>
	      <para>&Integer; number</para>
	      <para>(ex. <literal>3</literal>, <literal>100</literal>)</para>
	    </listitem>
	    <listitem>
	      <para>&StringType;</para>

	      <para>&StringType; has two forms: quoted and not quoted.
	    A quoted &StringType; can contain any
	    <acronym>ASCII</acronym> characters except the quotation
	    characters (' or ").  Quotations can be omitted if the
	    string has a form of a valid object identifier
	    (&EntityID;, &StepperID;, &SystemPath;, &FullID;, or
	    &FullPN;).</para>

	      <para>If the &StringType; is triple-quoted (by
             <literal>'''</literal> or <literal>"""</literal>), it
             can contain new-line characters.  (The current version still has
             some problems processing this.)</para>

	      <para>(ex. <literal>_C10_A</literal>,
	      <literal>Process:/A/B:P1</literal>, <literal>"It can
	      include spaces if double-quoted."</literal>,
	      <literal>'single-quote is available too, if you want to
	      use "double-quotes" inside.'</literal>)</para>
	    </listitem>

	    <listitem>
	      <para>List</para> 

	      <para>The list can contain &Real;, &Integer;, and
	       &StringType; values. This list can also contain other
	       lists, that is, the list can be nested.  A list must be
	       surrounded by brackets (<literal>[</literal> and
	       <literal>]</literal>), and the elements must be
	       separated by space characters.  In some cases outermost
	       brackets are omitted (such as in &EM; files, see
	       below).</para> 

	      <para>(ex. <literal>[ A 10 [ 1.0 "a string" 1e+10 ]
	      ]</literal> )</para>
	    </listitem>
	  </itemizedlist>
</para>
      </sect3>

      <sect3>
	<title>Dynamic type adaptation of property values</title>

	<para>The system automatically convert the type of the
         property value if it is different from what the object in
         the simulator (such as &Process; and &Variable;) expects to
         get.  That is, the system does not necessary raise an error
         if the type of the given value differs from the type the
         backend object accepts.  The system tries to convert the type
         of the value given in the model file to the requested type by
         the objects in the simulator.  The conversion is done by the
         objects in the simulator, when it gets a property value.  See also the
         following sections.</para>

	<para>The conversion is done in the following manner.  
<itemizedlist>
	    <title>How property value type adaptation is conducted</title>
	    <listitem>
	      <para>From a numeric value (&Real; or &Integer;)</para>
	      <itemizedlist>
		<listitem>
		  <para>To a &StringType;</para> 

		  <para>The number is simply converted to a character
		  string. For example, a number 12.3 is converted to a
		  &StringType; <literal>'12.3'</literal>.</para>
		</listitem>
		<listitem>
		  <para>To a list</para>

		  <para>A numeric value can be converted to a length-1
		  list which has that number as the first item.  For
		  example, 12.3 is equivalent to '[ 12.3 ]'.</para>
		</listitem>
	      </itemizedlist>
	    </listitem>
	    <listitem>
	      <para>From a &StringType;</para>
	      <itemizedlist>
		<listitem>
		  <para>To a numeric value (&Real; or &Integer;)</para> 
		  
		  <para>The initial portion of the &StringType; is
                  converted to a numeric value.  The number can be
                  represented either in a decimal form or a
                  hexadecimal form.  Leading white space characters
                  are ignored.  'INF' and 'NAN' (case-insensitive) are
                  converted to an infinity and a NaN (not-a-number),
                  respectively.  If the initial portion of the
                  &StringType; cannot be converted to a numeric value,
                  it is interpreted as a zero (0.0 or 0).  This
                  conversion procedure is equivalent to C functions
                  <function>strtol</function> and
                  <function>strtod</function>, according to the
                  destined type.</para>
		</listitem>
		<listitem>
		  <para>To a list</para>

		  <para>A &StringType; can be converted to a length-1
		  list which has that &StringType; as the first item.  For
		  example, 'string' is equivalent to '[ 'string' ]'.</para>
		</listitem>
	      </itemizedlist>
	    </listitem>
	    <listitem>
	      <para>From a list</para>
	      <itemizedlist>
		<listitem>
		  <para>To a numeric or a &StringType value</para> 

		  <para>It simply takes the first item of the list.
		  If necessary the taken value is further converted to
		  the destined types.</para>
		</listitem>
	      </itemizedlist>
	    </listitem>
	  </itemizedlist>


<note>
	    <title>Overflow and underflow when converting a property
	    value</title> 

	    <para>When converting from a &Real; number to an &Integer;, or
	    from a &StringType; to a numeric value, overflow and
	    underflow can occur during the conversion.  In this case
	    an exception (TYPE??) is raised when the backend object
	    attempts the conversion.</para>
	  </note>

</para>


      </sect3>

    </sect2>

  </sect1>


  <sect1>
    <title>E-Cell Model (&EM;) File Basics</title>

    <para>Now you know the &ecell;'s simulation model consists of what
     types of objects, and the objects have their properties.  The
     next thing to understand is how the simulation model is
     organized: the structure of the model.  But wait, learn the
     syntax of the &ecell; model (&EM;) file before proceeding to the
     next section would help you very much to understand the details
     of the structure of the model, because most of the example codes are
     in &EM;.</para>

    <sect2>
      <title>What is &EM;?</title>

      <para>
      In &app, the standard file format of model description and
      exchange is XML-based &EML; (E-Cell Model description Language).
      Although &EML; is an ideal means of integrating E-Cell with other
      software components such as GUI model editors and databases, it
      is very tedious for human users to write and edit by hand.</para>

      <para>E-Cell Model (&EM;) is a file
      format with a programming language-like syntax and a powerful
      embedded &empy; preprocessor, which is
      designed to be productive and intuitive especially when handled
      by text editors and other text processing programs such as
      UNIX's <application>grep</application>,
      <application>diff</application> and
      <application>cat</application>.  Semantics of &EM; and &EML; files
      are almost completely equivalent to each other, and going
      between these two formats is meant to be possible with no loss
      of information (some exceptions are comments and directions to
      the preprocessor in &EM;).  The file suffix of &EM; files is
      ".em".
    </para>

      <sect3>
	<title>Why and when use &EM;?</title>

	<para>Although <application>E-Cell Modeling
         Environment</application> (which is under development) will
         provide means of more sophisticated, scalable and intelligent
         model construction on the basis of &EML;, learning syntax and
         semantics of &EM; may help you to get the idea of how object
         model inside &ecell is organized and how it is driven to
         conduct simulations.  Furthermore, owing to the nature of
         plain programming language-like syntax, &EM; can be used as a
         simple and intuitive tool to communicate with other &ecell
         users.  In fact, this manual uses &EM; to illustrate how the
         model is constructed in &ecell;</para>

	<para>&EM; files can be viewed as &EML; generator scripts.</para>

      </sect3>

    </sect2>

    <sect2>
      <title>&EM; at a Glance</title>

      <para>Before getting into the details of &EM; syntax, let's
      have a look at a tiny example. It's very simple, but you do not 
      need to understand everything for the moment.</para>

      <example>
	<title>A tiny &EM; example</title>
	<programlisting linenumbering="numbered">
Stepper ODE45Stepper( ODE_1 ) 
{ 
        # no property 
} 
 
System System( / ) 
{ 
        StepperID       ODE_1;

        Variable Variable( SIZE )
        {
                Value   1e-18; 
        }
 
        Variable Variable( S ) 
        { 
                Value   10000; 
        } 
 
        Variable Variable( P ) 
        { 
                Value   0; 
        } 

        Process MassActionFluxProcess( E ) 
        { 
                Name  "A mass action from S to P."
                k     1.0; 

                VariableReferenceList [ S0 :.:S -1 ] 
                                      [ P0 :.:P 1 ];
        } 
 
} 
</programlisting>
      </example>

      <para>This example is a model of a mass-action differential
      equation. In this example, the model has a &Stepper;
      <literal>ODE_1</literal> of class
      <classname>ODE45Stepper</classname>, which is a generic ordinary
      differential equation solver.  The model also has the root
      system (<literal>/</literal>).  The root sytem has the
      <property>StepperID</property> property, and four &Entity;
      objects, &Variable;s <literal>SIZE</literal>,
      <literal>S</literal> and <literal>P</literal>, and the &Process;
      <literal>E</literal>.  <literal>SIZE</literal> is a special name
      of the &Variable;, that determines the size of the compartment.
      If the compartment is three-dimensional, it means the volume of
      the compartment in [L] (liter).  That value is used to calculate
      concentrations of other &Variable;s.  These &Entity; objects
      have their property values of several different types.  For
      example, <literal>StepperID</literal> of the root system is the
      string without quotes (<literal>ODE_1</literal>). The initial
      value given to <property>Value</property> property of the
      &Variable; <literal>S</literal> is an integer number
      <literal>10000</literal> (and this is automatically converted to
      a real number <literal>10000.0</literal> when the &Variable;
      gets it because the type of the <property>Value</property>
      property is &Real;).  <property>Name</property> property of the
      &Process; <literal>E</literal> is the quoted string <literal>"A
      mass action from S to P"</literal>, and '<property>k</property>'
      of it is the real number <literal>1.0</literal>.
      <property>VariableReferenceList</property> property of
      <literal>E</literal> is the list of two lists, which contain
      strings (such as <literal>S0</literal>), and numbers (such as
      <literal>-1</literal>).  The list contain relative &FullID;s
      (such as <literal>:.:S</literal>) without quotes.</para>

    </sect2>


    <sect2>
      <title>General Syntax of &EM;</title>

      <para>Basically an &EM; is (and thus an &EML; is) a list of just one
      type of directives: <emphasis>object instantiation</emphasis>.
      As we have seen, &ecell;'s simulation models have only two types 
      of 'objects'; &Stepper; and &Entity;.   After
      creating an object, property values of the object must be set.
      Therefore the object
      instantiation has two steps: (1) creating the object
      and (2) setting properties.</para>

      <sect3>
	<title>General form of object instantiation statements</title>

	<para>The following is the general form of definition
(instantiation) of an object in &EM;:

<programlisting>
TYPE CLASSNAME( ID )
"""INFO (<emphasis>optional</emphasis>)"""
{ 
        PROPERTY_NAME_1 PROPERTY_VALUE_1;
        PROPERTY_NAME_2 PROPERTY_VALUE_2;
        ...
        PROPERTY_NAME_n PROPERTY_VALUE_n;
} 
</programlisting>
where:
<itemizedlist>
	    <listitem>
	      <para>TYPE</para>
	      <para>The type of the object, which is one of the followings:
      <itemizedlist>
		  <listitem>
		    <para>&Stepper;</para>
		  </listitem>
		  <listitem>
		    <para>&Variable;</para>
		  </listitem>
		  <listitem>
		    <para>&Process;</para>
		  </listitem>
		  <listitem>
		    <para>&System;</para>
		  </listitem>
		</itemizedlist>
</para>
	    </listitem>

	    <listitem>
	      <para>ID</para>
	      <para>This is a <emphasis>StepperID</emphasis> if the
		object type is &Stepper;.  If it is &System;, put a
		&SystemPath; here.  Fill in an &EntityID; if it is
		a &Variable; or a &Process;.</para>
	    </listitem>

	    <listitem>
	      <para>CLASSNAME</para>

	      <para>The classname of this object.  This class must be
a subclass of the baseclass defined by <emphasis>TYPE</emphasis>.  For
example, if the <emphasis>TYPE</emphasis> is &Process;,
<emphasis>CLASSNAME</emphasis> must be a subclass of &Process;, such
as <classname>MassActionFluxProcess</classname>.</para>
	    </listitem>

	    <listitem>
	      <para>INFO</para>

	      <para>An annotation for this object. This field is
		optional, and is not used in the simulation.  A quoted
		single-line ("string") or a multi-line string
		("""multi-line string""") can be put here.</para>
	    </listitem>

	    <listitem>
	      <para>PROPERTY</para>

	      <para>An object definition has zero or more properties.</para> 

	      <para>The property starts with an unquoted property name
		string, followed by a property value, and ends with a
		semi-colon (<literal>;</literal>).  For example, if
		the property name is
		<property>Concentration</property> and the value is
		<literal>10.0</literal>, it may look like:
		<informalexample>
		  <programlisting>Concentration 10.0;</programlisting></informalexample></para>

	      <para>&Real;, &Integer;, &StringType;, and List are
		allowed as property value types (See the Object Properties
		section above).</para> 

	      <para>If the value is a List, outermost
		brackets are omitted.  For example, to put a list
		<programlisting>[ 10 "string" [ LIST ] ]</programlisting> 
                into a property slot <literal>Foo</literal>, write a
		line in the object definition like this:
<informalexample>
		  <programlisting>Foo 10 "string" [ LIST ];</programlisting>
		</informalexample>
<note>
		  <title>Why the outermost brackets can be ommited?</title> 

		  <para>All property values are lists, even if it is
		    a scalar &Real; number.  Remember a number '1.0' is
		    interconvertible with a length-1 list '[ 1.0 ]'. 
                    Therefore the system can correctly interpret property
                    values without the brackets.
                    </para>

		  <para>In other words, if the property value is
		    bracketed, for example, the following property value
<programlisting>Foo [ 10 [ LIST ] ];</programlisting> 
                    is interpreted by the system as a length-1 List 
<programlisting>[ [ 10 [ LIST ] ] ]</programlisting> 
                    of which the first item is a list
<programlisting>[ 10 [ LIST ] ]</programlisting> 
                    This may or may not be what you intend to have.</para>
		</note>
</para>

	    </listitem>

	  </itemizedlist>



</para>

      </sect3>
    </sect2>

    <sect2>
      <title>Macros and Preprocessing</title>

      <para>Before converting to &EML;,
         <command>ecell3-em2eml</command> command invokes the &empy;
         program to preprocess the given &EM; file.
        </para>

      <para>By using &empy;, you can embed any &Python;
	expressions and statements after '@' in an &EM; file.  Put
	a &Python; expression inside '@( <replaceable>python expression</replaceable> )', and the
	macro will be replated with an evaluation of the expression.
	If the expression is very simple, '()' can be ommited. Use '@{
	<replaceable>pytyon statements</replaceable> }' to embed &Python; statements.  For
	example, the following code:

<programlisting>@(AA='10')
@AA</programlisting> is expanded to:
	<programlisting>10</programlisting>

        Of course the statement can be multi-line.  This code 

<programlisting>
@{
  def f( str ):
      return str + ' is true.'
}

@f( 'Video Games Boost Visual Skills' )
</programlisting>

        is expanded to

<programlisting>Video Games Boost Visual Skills is true.</programlisting>
</para>

      <para>&empy; can also be used to include other files.  The
following line is replaced with the content of the file
<filename>foo.em</filename> immediately before the &EM; file is
converted to an &EML;: 

<programlisting>@include( 'foo.em' )</programlisting>
</para>

      <para>Use <option>-E</option> option of
	<command>ecell3-em2eml</command> command to see what happens
	in the preprocessing.  With this option, it outputs the result of the
	preprocessing to standard output and stops without creating an
	&EML; file.</para>

      <para>It has many more nice features.  See the appendix A
	for the full description of the &empy; program.</para>
    </sect2>

    <sect2>
      <title>Comments</title>

      <para>The comment character is a sharp '#'.  If a line contains
         a '#' outside a quoted-string, anything after the character
         is considered a comment, and not processed by the
         <command>ecell3-em2eml</command> command.</para>

      <para>This is processed differently from the &empy; comments
         (@#).  This comment character is processed by the &empy; as a
         usual character, and does not have an effect on the
         preprocessor.  That is, the part of the line after '#' is not
         ignored by &empy; preprocessor.   To comment out an &empy; macro, 
         the &empy; comment (@#) must be used.
         </para>
    </sect2>

  </sect1>

  <sect1>
    <title>Structure Of The Model</title>

    <sect2>
      <title>Top Level Elements</title>

      <para>Usually an &EM; has one or more &Stepper; and one or more &System;
	statements.  These statements are top-level elements of the file.
        General structure of an &EM; file may look like this:
<programlisting>
STEPPER_0
STEPPER_1
...
STEPPER_n

SYSTEM_0 # the root system ( '/' )
SYSTEM_1
...
SYSTEM_m
</programlisting>

        <literal>STEPPER_?</literal> is a &Stepper; statement and 
        <literal>SYSTEM_?</literal> is a &System; statement.
</para>

    </sect2>

    <sect2>

      <title>Systems</title>

      <sect3>
	<title>The root system</title>
	
	<para>The model must have a &System; with a
	 &SystemPath; '<literal>/</literal>'.  This &System; is called
	 the <emphasis>root system</emphasis> of the model.

<programlisting>
System System( / )
{
    # ...
}
</programlisting>
</para>

	<para>The class of the root system is always
         <classname>System</classname>, no matter what
         class you specify.  This is because the simulator creates the
         root sytem when it starts up, before loading the model
         file. That is, the statement does not actually create the
         root system object when loading the &EML; file, but just set
         its property values.  Consequently the class name specified
         in the &EML; is ignored.  The model file must always have
         this root system statement, even if you have no property to
         set.
      </para>

      </sect3>

      <sect3>
	<title>Constructing the system tree</title>

	<para>If the model has more than one &System; objects, it must
         form a tree which starts from the root system (/).  For
         example, the following is <emphasis>not</emphasis> a valid &EM;.

<programlisting>
System System( / )
{
}

System System( /CELL0/MITOCHONDRION0 )
{
}
</programlisting>

         This is invalid because these two &System; objects,
         <literal>/</literal> and
         <literal>/CELL0/MITOCHONDRION0</literal> are not connected to
         each other, nor form a single tree.  Adding another &System;,
         <literal>/CELL0</literal>, makes it valid.

<programlisting>
System System( / )
{
}

System System( /CELL0 )
{
}

System System( /CELL0/MITOCHONDRION0 )
{
}
</programlisting>

         Of course a &System; can have arbitrary number of sub-systems.

<programlisting>
System System( / )
{
}

System System( /CELL1 ) {}
System System( /CELL2 ) {}
System System( /CELL3 ) {}
# ...
</programlisting>

</para>


	<note>
	  <title>Planned support for model composition</title>

	  <para>In future versions, the system will support composing
             a model from multiple model files (&EM;s or &EML;s).
             This is not the same as the &EM;'s file inclusion by
             &empy; preprocessor.</para>
	</note>

      </sect3>


      <sect3>
	<title>Sizes of the Systems</title>

	<para>If you want to define the size of a &System;, create a
         &Variable; with an ID '<literal>SIZE</literal>'.  If the
         &System; models a three-dimensional compartment, the
         <literal>SIZE</literal> here means the volume of that
         compartment.  The unit of the volume is [L] (liter).  In the
         next example, size of the root system is
         <literal>1e-18</literal>.

<programlisting>System System( / )
{
    Variable Variable( SIZE )    # the size (volume) of this compartment
    {
        Value   1e-18;
    }
}</programlisting>
        </para>
	
	<para>If a System has no '<literal>SIZE</literal>' &Variable;,
         then it shares the <literal>SIZE</literal> &Variable; with
         its supersystem.  The root system always has its SIZE
         &Variable;.  If it is not given by the model file, then the
         simulator automatically creates it with the default value
         1.0.  The following example has four &System; objects, and
         two of them (<literal>/</literal> and
         <literal>/COMPARTMENT</literal>) have their own
         <literal>SIZE</literal> variables.  Remaining two
         (<literal>/SUBSYSTEM</literal> and its subsystem
         <literal>/SUBSYSTEM/SUBSUBSYSTEM</literal>) share the
         <literal>SIZE</literal> &Variable; with the root system.


<programlisting>
System System( / )                       # SIZE == 1.0 (default)
{
    # no SIZE
}

System System( /COMPARTMENT )            # SIZE == 2.0e-15
{
    Variable Variable( SIZE )
    {
        Value 2.0e-15
    }
}

System System( /SUBSYSTEM )              # SIZE == SIZE of the root sytem
{
    # no SIZE
}

System System( /SUBSYSTEM/SUBSUBSYSTEM ) # SIZE == SIZE of the root system
{
    # no SIZE
}
</programlisting>
</para>

	<note>
	  <title>SIZE must be a positive real number</title>
	  <para>Behavior of the system when zero or negative number is
	  set to SIZE is undefined.</para>
	</note>

	<note>
	  <title>Unit of the size</title> <para>Currently, the unit of
	  the SIZE is (10 cm)^<emphasis>d</emphasis>, where d is dimension
	  of the &System;.  If d is 3, it is (10 cm)^3 == liter.  This
	  specification is still under discussion, and is subject to
	  change in future versions.</para>
	</note>
      </sect3>



    </sect2>

    <sect2>
      <title>Variables and Processes</title>

      <para>A &System; statement has zero, one or more &Variable; and
	&Process; statements in addition to its properties.

<programlisting>
System System( / )
{
    # ... properties of this System itself comes here..

    Variable Variable( V0 ) {}
    Variable Variable( V1 ) {}
    # ...
    Variable Variable( Vn ) {}

    Process SomeProcess( P0 )  {}
    Process SomeProcess( P1 )  {}
    # ...
    Process OtherProcess( Pm ) {}
}
</programlisting>

      Do not put a &System; statement inside &System;.
</para>
    </sect2>



    <sect2>
      <title>Connecting Steppers with Entity Objects</title>

      <para>Any &Process; and &Variable; object in the model must be
         connected with a &Stepper; by setting its
         <property>StepperID</property> property.  If the
         <property>StepperID</property> of a &Process; is omitted, it
         defaults to that of its supersystm (the &System; the &Process;
         belongs to).  <property>StepperID</property> of &System; cannot
         be omitted.</para>

      <para>In the following example, the root sytem is connected to
         the &Stepper; <literal>STEPPER0</literal>, and the &Process;
         <literal>P0</literal> and <literal>P1</literal> belong to
         &Stepper;s <literal>STEPPER0</literal> and
         <literal>STEPPER1</literal>, respectively.

<programlisting>
Stepper SomeClassOfStepper( STEPPER0 )    {}
Stepper AnotherClassOfStepper( STEPPER1 ) {}

System System( / )  # connected to STEPPER0
{
    StepperID     STEPPER0;

    Process AProcess( P0 )     # connected to STEPPER0
    {
        # No StepperID specified.
    }

    Process AProcess( P1 )     # connected to STEPPER1
    {
        StepperID     STEPPER1;
    }
}
</programlisting>
</para>

      <para>Connections between &Stepper;s and &Variable;s are
	automatically determined by the system, and cannot be
	specified manually.  See the next section.</para>

    </sect2>

    <sect2>
      <title>Connecting Variable Objects with Processes</title>

      <para>A &Process; object changes values of &Variable;
         object(s) according to a certain procedure, such as the law
         of mass action.  What &Variable; objects the &Process; works
         on cannot be determined when it is programmed, but it must be
         specified by the modeler when the &Process; takes part in the
         simulation.  
         <property>VariableReferenceList</property> property of the
         &Process; relates some &Variable; objects with the &Process;.</para>

      <para><property>VariableReferenceList</property> is a list of
         <emphasis>&VariableReference;s</emphasis>.  A
         &VariableReference;, in turn, is usually a list of the
         following four elements:

<programlisting>[ <replaceable>reference_name</replaceable> <replaceable>FullID</replaceable> <replaceable>coefficient</replaceable> <replaceable>accessor_flag</replaceable> ]</programlisting>
         The last two fields can be omitted:         

<programlisting>[ <replaceable>reference_name</replaceable> <replaceable>FullID</replaceable> <replaceable>coefficient</replaceable> ]</programlisting>

         or,

<programlisting>[ <replaceable>reference_name</replaceable> <replaceable>FullID</replaceable> ]</programlisting>

          These elements have the following meanings.

<orderedlist>
	  <listitem>
	    <para>Reference name</para>

	    <para>This field gives a local name inside the &Process;
               to this &VariableReference;.  Some &Process; classes
               use this name to identify particular instances of
               &VariableReference;.</para>

	    <para>Currently, this reference name must be set for all
               &VariableReference;s, even if the &Process; does not
               use the name at all.
               </para>

	    <para>Lexical rule for this field is the same
               as the &EntityID;; leading alphabet or '_' with
               trailing alphabet, '_', and numeric characters.</para>
	  </listitem>

	  <listitem>
	    <para>&FullID;</para>

	    <para>This &FullID; specifies the &Variable; that this
               &VariableReference; points to.</para>

	    <para>The &SystemPath; of this &FullID; can be relative.
	       Also, &EntityType; can be omitted.   That is, writing
               like this is allowed:

<programlisting>:.:S0</programlisting>

             instead of

<programlisting>Variable:/CELL:S0</programlisting>

             , if the &Process; exists in the &System <literal>/CELL</literal>.
</para>

	  </listitem>

	  <listitem>
	    <para>Coefficient (<emphasis>optional</emphasis>)</para>

	    <para>This coefficient is an integer value that defines
               weight of the connection between the &Process; and the
               &Variable; that this &VariableReference; points to.
              </para>

	    <para>If this value is a non-zero integer, then this
               &VariableReference; is said to be a <emphasis>mutator
               &VariableReference;</emphasis>, and the &Process; can
               change the value of the &Variable;.  If the value is zero,
               this &VariableReference; is not a mutator, and the &Process;
               should not change the value of the &Variable;.
               </para>

	    <para>If the &Process; represents a chemical reaction,
               this value is usually interpreted by the &Process; as a
               stoichiometric constant.  For example, if the
               coefficient is -1, the value of the &Variable; is
               decreased by 1 in a single occurence of the forward
               reaction.</para>

	    <para>If omitted, <emphasis>this field defaults to
	      zero</emphasis>.</para>
	  </listitem>

	  <listitem>
	    <para><emphasis>isAccessor</emphasis> flag (<emphasis>optional</emphasis>)</para>

	    <para>This is a binary flag; set either 1 (true) or 0 (false).  If
               this <emphasis>isAccessor</emphasis> flag is false, it
               indicates that the behavior of &Process; is not
               affected by the &Variable; that this
               &VariableReference; points to.  That is, the &Process;
               never reads the value of the &Variable;. The &Process;
               may or may not change the &Variable; regardless of the value
               of this field.</para>

            <para>Some &Process; objects automatically sets this
               information, if it knows it never changes
               the value of the &Variable; of this
               &VariableReference;.  Care should be taken when you set
               this flag manually, because many &Process; classes do
               not check this flag when actually read the value of the
               &Variable;.
             </para>

	    <para><emphasis>The default is 1 (true).</emphasis> This
               field is often omitted.</para>

	    <note>
	      <title>How isAccessor flag is used in the
		simulation</title> <para>In multi-stepper simulations,
		this information sometimes helps the system to run
		efficiently.  If the system knows, for example, all
		&Process; objects in the &Stepper; <literal>A</literal>
		do not change any &Variable; connected to the other
		&Stepper; <literal>B</literal>, it can give
		<literal>B</literal> more chance to have larger stepsizes,
		rather than always checking whether &Stepper;
		<literal>A</literal> changed some of the &Variable; objects. 
                This flag is mainly used when there are more than one
                &Stepper;s.</para>
	    </note>

	  </listitem>
	</orderedlist>

	</para>

      <para>
	 Consider a reaction &Process; in the root system,
	 <literal>R</literal>, consumes the &Variable;
	 <literal>S</literal> and produces the &Variable;
	 <literal>P</literal>, taking <literal>E</literal> as the
	 enzyme.  This class of &Process; requires to give the enzyme
	 as a &VariableReference; of name <literal>ENZYME</literal>.
	 All the &Variable; objects are in the root system. In &EM;,
	 <property>VariableReferenceList</property> of this
	 &Process; may appear like this:

<programlisting>
System System( / )
{
    # ...
    Variable Variable( S ) {}
    Variable Variable( P ) {}
    Variable Variable( E ) {}

    Process SomeReactionProcess( R )
    {
        # ...
        VariableReferenceList [ S0     :.:S -1 ]
                              [ P0     :.:P  1 ]
                              [ ENZYME :.:E  0 ];

    }
}
</programlisting>

</para>

    </sect2>

  </sect1>

  <sect1>
    <title>Modeling Schemes</title>
    
    <para>&ecell; is a multi-algorithm simulator.  It can run any kind
     of simulation algorithms, both discrete and continuous, and these
     simulation algorithms can be used in any combinations.   This
     section exlains how you can find appropriate set of object
     classes for your modeling and simulation projects.  This
     section does not give a complete list of available object classes
     nor detailed usage of those classes.  Read the chapter "Standard
     Dynamic Module Library" for more info.</para>

    <sect2>
      <title>Discrete or Continuous ?</title>

      <para>&ecell; can model both discrete and continuous processes,
       and these can be mixed in simulation.  The system models
       discrete and continuous systems by discriminating two different
       types of &Process; and &Stepper; objects: discrete &Process; /
       &Stepper; and continuous &Process; / &Stepper;.</para>

      <note>
	<title>Variable is discrete and continous</title>

	<para>&Variable; and &System; do not have special discrete and
      continuous classes.  The base &Variable; class supports both
      discrete and continous operations, because it can be connected
      to any types of &Process; and &Stepper; objects.  &System;
      objects do not do any computation that needs to discriminate
      discrete and continuos.</para>
      </note>




      <sect3>
	<title>Discrete classes</title>

	<para>A &Process; object that
       models discrete changes of one or more &Variable; objects is called a
       <emphasis>discrete &Process;</emphasis>, and it must be used in
       conjunction with a <emphasis>discrete &Stepper;</emphasis>.  A
       discrete &Process; directly changes the <emphasis>values</emphasis> of
       related &Variable; objects when its &Stepper; requests to do so.
</para>

      </sect3>

      <sect3>
	<title>Continuous classes</title>

	<para>On the other hand, a &Process; that calculates continuous
       changes of &Variable; objects is called a <emphasis>continuous
       &Process;</emphasis>, and is used in combination with a
       <emphasis>continuous &Stepper;</emphasis>.  Continuous
       &Process; objects simulate the phenomena that represents by
       setting <emphasis>velocities</emphasis> of connected &Variable;
       objects, rather than directly changing their values in the case
       of discrete &Process; objects.  A continuous &Stepper;
       integrates the values of &Variable; objects from the velocities
       given by the continuous &Process; objects, and determines when
       the velocities should be recalculated by the &Process; objects.
       A typical application of continuous &Process; and &Stepper;
       objects is to implement differential equations and differential
       equation solvers, respectively, to form a simulation system
       of the system of differential equations.</para>
      </sect3>

    </sect2>

    <sect2>
      <title>Types of discrete object classes</title>

      <para>There are two types of discrete &Process; / &Stepper;
       classes: discrete and discrete event.</para>

      <itemizedlist>
	<listitem>
	  <para>Discrete</para>

	  <para>A discrete &Process; changes values of connected
	  &Variable; objects (i.e. appear in its
	  <property>VariableReferenceList</property> property)
	  discretely.  In the current version, there is no special
	  class named <classname>DiscreteProcess</classname>, because
	  the base &Process; class is already a discrete &Process; by
	  default. The manner of the change of &Variable; values is
	  determined from values of its accessor &VariableReference;s,
	  its property values, and sometimes the current time of the
	  &Stepper;.  Unlike discrete event &Process;, which is
	  explained in the next item, it does not necessary specify
	  when the discrete changes of &Variable; values occur.
	  Instead, it is unilaterally determined and fired by a
	  discrete &Stepper;.</para>

	  <para>A &Stepper; that requires all &Process; objects
           connected is discrete &Process; objects is call a discrete
           &Stepper;.  The current version has no special class
           <classname>DiscreteStepper</classname>, because the base
           &Stepper; class is already discrete.</para>

	</listitem>


	<listitem>
	  <para>Discrete event</para>

	  <para>Discrete event is a special case of discreteness.  The
           system provides <classname>DiscreteEventStepper</classname>
           and <classname>DiscreteEventProcess</classname> classes for
           discrete-event modeling.  In addition to the ordinary
           firing method (<methodname>process()</methodname> method)
           of the base &Process; class, the
           <classname>DiscreteEventProcess</classname> defines a
           method to calculate <emphasis>when</emphasis> is the next
           occurrence of the event (the discrete change of &Variable;
           values that this discrete event &Process; models) from
           values of its accessor &VariableReference;s, its property
           values, and the current time of the &Stepper;.
           <classname>DiscreteEventStepper</classname> uses
           information given by this method to determine when each of
           discrete event &Process; should be fired.
           <classname>DiscreteEventStepper</classname> is
           instantiatable.  See the chapter
           Standard Dynamic Module Library for more detailed
           description of how
           <classname>DiscreteEventStepper</classname> works.</para>

	</listitem>
      </itemizedlist>

      <para>Followings are some examples of discrete types of object
      classes that the current version of &ecell; provides by default.</para>

      <sect3>
	<title>DiscreteTimeStepper</title>

	  <para>A type of discrete &Stepper; that is provided by the
           system is
           <emphasis><classname>DiscreteTimeStepper</classname></emphasis>.
           This class of &Stepper;, when instantiated, calls all
           discrete &Process; objects with a fixed user-specified
           time-interval.  For example, if the model has a
           <classname>DiscreteTimeStepper</classname> with 0.001
           (second) of <property>StepInterval</property> property, it
           fires all of its &Process; objects every milli-second.
           <classname>DiscreteTimeStepper</classname> is discrete time
           because it does not have time between steps; it ignores a
           signal from other &Stepper; (<emphasis>&Stepper;
           interruption</emphasis>) that notifies a change of system
           state (values of &Variable; objects) that may affect its
           &Process; objects.  Such change is reflected in the next
           step.
            </para>
      </sect3>

      <sect3>
	<title>PassiveStepper</title>

	<para>Another class of discrete &Stepper; is
	<classname>PassiveStepper</classname>.  This can be partially
	seen as a <classname>DiscreteTimeStepper</classname> with
	an infinite <property>StepInterval</property>, but there is a
	difference.  Unlike
	<classname>DiscreteTimeStepper</classname>, this does
	<emphasis>not</emphasis> ignore &Stepper; interruptions, which
	notify change in the system state that may affect this
	&Stepper;'s &Process; objects.</para>
	
	<para>This &Stepper; is used when some special procedures
         (coded in discrete &Process; objects) must be invoked when
         other &Stepper; object may have changed a value or a velocity
         of at least one &Variable; that this &Stepper;'s &Process; objects
         accesses.</para>

      </sect3>

      <sect3>
	<title>GillespieProcess and NRStepper (Gillespie-Gibson pair)</title>

	  <para>An example of discrete-event classes provided by
           &ecell; is a pair of
           <classname>GillespieProcess</classname> and
           <classname>NRStepper</classname>.
           <classname>GillespieProcess</classname>, which is a
           subclass of <classname>DiscreteEventProcess</classname>,
           calculates a time of the next occurence of the reaction
           using Gillespie's reaction probability equation and a
           random number.  When this class is used with a &Stepper;
           (by setting a value of <property>StepperID</property>
           property) that implements the Gibson's Next Reaction
           Method, <classname>NRStepper</classname>, &ecell; conducts
           a Gillespie-Gibson stochastic simulation of elementary
           chemical reactions.  In fact,
           <classname>NRStepper</classname> is an alias to
           <classname>DiscreteEventStepper</classname>, because
           Gillespie-Gibson method is actually a typical
           discrete-event simulation. (See the next tutorial for
           detailed usage of <classname>GillespieProcess</classname>
           and <classname>NRStepper</classname>.)</para>
      </sect3>

    </sect2>

    <sect2>
      <title>Types of continuous object classes</title>

      <sect3>
	<title>Classes for ordinary differential equations</title>

	<para>Continuous &Process; and &Stepper; objects are usually used
       to model differential systems: a set of differential equations.</para>

	<para>FIXME: more here.</para>
      </sect3>

      <sect3>
	<title>Special purpose continuous object classes</title>

	<para>FIXME: incomplete.  essyns, gma, s-system</para>

      </sect3>

    </sect2>


  </sect1>



  <sect1>
  <title>Modeling Convensions</title>

  <sect2>
  <title>Units</title>

      <para>
      In &app;, the following units are used.
         This standard is meant only for the simulator's internal
         representation, and any units can be used in the process of
         modeling.  However, it must be converted to these standard units
         before loaded by the simulator.

       <itemizedlist>

	  <listitem>
	    <para>Time</para>

	    <para>s (second)</para>
	  </listitem>

	  <listitem>
	    <para>Volume</para>
	    <para>L (liter)</para>
	  </listitem>

	  <listitem>
	    <para>Concentration</para>
	    <para>Molar concentration (M, or molar per L (liter), used for example in <property>MolarConc</property> property of a &Variable; object) or,</para>
	    <para>Number concentration (number per L (liter), <property>NumberConc</property> property of &Variable; has this unit).</para>
	  </listitem>
	</itemizedlist>


</para>
    </sect2>

  </sect1>



  

  </chapter>


<!--
Local Variables:
mode: sgml
sgml-parent-document: ("ecell3-users-manual.xml" "book" "chapter")
End:
-->

